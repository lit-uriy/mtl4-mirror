// vim: syn=cpp:
#ifndef STD_TUPLE_TUPLE_IO
#define STD_TUPLE_TUPLE_IO

#include "tuple"
#include <iostream>
#include <string>
#include <locale>
#include <cctype>

#define STD_TUPLE_IN_IO

#include "detail/manip.hpp"

namespace STD_TUPLE_NS {
  // Printing and reading routines
  namespace detail {
    template <class F, int Start, int Len, class T>
    struct printread_tuple_type {
      static void run(F& f, T& x) {
	f.var(STD_TUPLE_NS::get<Start>(x));
	if (Start+1 != Len)
	  f.constant(string_ios_manip<tuple_delimiter_tag,typename F::stream_type>(f.stream).get(" "));
	printread_tuple_type<F,Start+1, Len, T>::run(f,x);
      }
    };

    template <class F, int Len, class T>
    struct printread_tuple_type<F,Len,Len,T> {
      static void run(F& f, T&) {
	f.constant(string_ios_manip<tuple_close_tag,typename F::stream_type>(f.stream).get(")"));
      }
    };

    template <class F, class T>
    void printread_tuple(F& f, T& x) {
      f.constant(detail::string_ios_manip<detail::tuple_open_tag,typename F::stream_type>(f.stream).get("("));
      detail::printread_tuple_type<F, 0, tuple_size<T>::value, T>::run(f,x);
    }

    template <class O>
    struct print_tuple_functor {
      O& stream;
      typedef O stream_type;
      print_tuple_functor(O& o_): stream(o_) {}

      template <class T>
      void var(const T& x) {stream << x;}

      template <class T>
      void constant(const T& x) {stream << x;}
    };

    template <class I>
    struct read_tuple_functor {
      I& stream;
      typedef I stream_type;
      read_tuple_functor(I& i_): stream(i_) {}

      template <class T>
      void var(T& x) {
	stream >> x;
      }

      template <class T>
      void constant(const T& x) {
	ws(stream);
	for (typename T::const_iterator i = x.begin(); i != x.end(); ++i)
	  if (!std::isspace(*i, std::locale("C")))
	    if (stream.get() != *i) {
	      stream.unget();
	      stream.setstate(std::ios::failbit);
	    }
      }
    };
  }

  template <class O, class T>
  O& print_tuple(O& o, const T& x) {
    detail::print_tuple_functor<O> f(o);
    detail::printread_tuple(f,x);
    return o;
  }

  template <class O, class T>
  typename detail::enable_if<
    is_tuple<T>::value,
    O&>::type
  operator << (O& o, const T& x) {
    print_tuple(o,x);
    return o;
  }

  template <class I, class T>
  I& read_tuple(I& i, T& x) {
    detail::read_tuple_functor<I> f(i);
    detail::printread_tuple(f,x);
    return i;
  }

  template <class I, class T>
  typename detail::enable_if<
    is_tuple<T>::value,
    I&>::type
  operator >> (I& i, T& x) {
    read_tuple(i,x);
    return i;
  }

}


#undef STD_TUPLE_IN_IO
// Prevent users from including detail/* after this (I/O stuff)

#endif
