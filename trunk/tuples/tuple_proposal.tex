\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

%\usepackage[finnish]{babel}

\newcommand{\effects}{\noindent \textbf{Effects:}}
\newcommand{\returns}{\noindent \textbf{Returns:}}
\newcommand{\returntype}{\noindent \textbf{Return type:}}
\newcommand{\requires}{\noindent \textbf{Requires:}}
\newcommand{\notes}{\noindent \textbf{Notes:}}
\newcommand{\values}{\noindent \textbf{Value:}}
\newcommand{\example}{\noindent \textbf{Example:}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\concept}[1]{\textsf{#1}}

\author{Jaakko Järvi}

\title{Proposal for adding tuple types into the standard library\\N1382=02-0040}


\begin{document}
\maketitle{}

Osat:

- introduction to tuples

- text in standard

- reference implementation

- about the reference implementation


TODO:

- laita comparison-operaattoreihin conversion to bool before ! operator
-  change static cast to reintepret cast in or something in manipulators

\section{Motivation}

Tuple types exist in several programming languages, such as Haskell, 
ML, Python, Eiffel, to name a few. Tuple types are fixed size heterogeneous 
containers. They are a general purpose utility, 
adding to the expressiveness of the language. Some examples of 
common uses for tuple types are:
\begin{itemize}
\item Return types of functions that need to have more than one return type.
\item Grouping related types or objects (such as parameter lists) into a single entity.
\item Simultaneous assignment of multiple values.
\end{itemize}

This proposal describes tuple types for C++. 
The standard library provides the \code{pair}
template which is being used throughout the standard library, demonstrating 
the usefulness of tuple-like constructs.
The proposed tuple type is basically a generalization of the \code{pair} 
template from two to arbitrary (up to a predefined limit) number of elements.
Compared to pairs, the proposed tuples:
\begin{itemize}
\item Support a wider range 
of element types (e.g. references).
\item Support input from and output to a stream, customizable
with specific manipulators.
\item A mechanism for 'unpacking' tuple elements into stand alone variables 
(\code{tie} functions).
\end{itemize}

\section{Impact on the standard}

All features described in this document can be implemented as a library,
without requiring any core language changes.
However, the implementation would benefit from a set of core language changes:
\begin{itemize}
\item Variable length template argument lists.
\item Making reference to a reference to some type \code{T} equal to 
reference to \code{T} (Issue XXX)
\item Allowing default arguments (both template and function) for function
templates (Issue XXX).
\item Ignoring qualifiers that are added to function types. (Issue YYY)
\end{itemize}
%
Furthermore, even within the current language
there are at least a few different approaches for implementing
tuples underneath a common interface.

For these reasons we do not suggest a fixed implementation be standardized, 
but rather the proposed text for the standard states the requirements for
a tuple implementation 
in the form of valid expressions and the semantics of these expressions.

Another reason for this approach is that it leaves
room for a built-in tuple type, or for a tuple template with some special
support from the compiler, which we see worth considering.
A library solution still falls short in some aspects, 
compared to built-in tuple types in other languages.
For instance, in Python and Haskell ???, the function argument list is 
implicitly a tuple.
This is a feature that cannot be built into C++ as a library.
Tuples as built-in types are discussed more in section~\ref{Built-in tuples}.

In sum, this proposal defines the requirements for a tuple type 
to be implemented as a library.
The requirements are stated as to allow a future transition to 
a more feature-rich built-in tuple type.

The concrete additions and changes to the standard are:
\begin{itemize}
\item A new section describing the requirements for the tuple template
\item Backward compatible changes to \code{pair} to allow pairs act
as tuples.
\item An utility class and two utility function templaets to be used in passing
reference arguments through a pass-by-copy interface.
These templates have uses outside of tuples and should thous be described
elsewhere in the standards, possibly together with the type\_traits library~\cite{type_traits_boost,type_traits_paper}, which has been suggested for
standardization~\cite{type_traits_proposal}.
\end{itemize}

We propose tuple definitions to be included by including the \code{<utility>} 
header, which is where \code{pair} resides in.
However, operators for reading tuples from a stream and writing tuples into
a stream do introduce a dependency to \code{<istream>} and \code{<ostream>},
hence a new header \code{<tupleio>} is proposed.

\section{Tuples in a nutshell}

The purpose of this section is to give an informal overview of the 
features that the tuple types, implemented as a library, provide.

\subsection{Defining tuple types}

The \code{tuple} template can be instantiated with any number of arguments
from 0 to some predefined upper limit. In the Boost Tuple library~\ref{boost_tuples}, this limit is 10.
The argument types can be any valid C++ types.
Examples:
\begin{verbatim}
typedef tuple<A, const B, volatile C, const volatile D> t1;
typedef tuple<int, int&, const int&, const volatile int&> t2;
typedef tuple<void, int()(int)> t3;
\end{verbatim}
Note that even types of which no objects can be created (cf. \code{void}, \code{int()(int)}), are valid tuple elements.
Naturally an object of a tuple with such an element type cannot be created 
either (see~\ref{about_valid_element_types}).

\subsection{Constructing tuples}

A $n$ element tuple has a default constructor, 
converting copy constructor, 
and a constructor with $n$ parameters.
The types of the elements restrict which constructors can be used:
\begin{itemize}
\item If an $n$-element tuple is constructed with a constructor taking 
0 elements, all elements must be default constructible.

\item If an $n$-element tuple is constructed with a constructor taking 
$n$ elements, all elements must be copy constructible and implicitly 
convertible from the corresponding argument.
For example
\begin{verbatim}
tuple<int, const int, std::string>(1, 'a', "Hi")
\end{verbatim}

\item If an $n$-element tuple is constructed with the converting copy 
constructor, the argument type must be a model of the \concept{Tuple} concept
and the each element must be elementwise copy constructible.
\end{itemize}

\begin{verbatim}
tuple<int, float, std::string> t1;
t1 = tuple<char, int, char[]>('a', 1, "Hi");
\end{verbatim}


\subsection{Assignment}

The assignment operation is defined from any object that models
the \concept{Tuple} concept and where the element types are elementwise 
assignable.

\subsection{Number of elements, element types}

Tuples make the number of element accessible as a compile time constant 
\code{size}.
\begin{verbatim}
tuple<int, int, int, int>::size; // equals 4
\end{verbatim}

The type of the \code{N}th element can be accessed as a typedef within
a nested template \code{element}:
\begin{verbatim}
tuple<int, char, float, double>::element <2>::type // float
\end{verbatim}
Indexing is zero based. Index out of bounds results in a compilation error.

\subsection{Element access}

Let \code{t} be a tuple object. 
The expression t[index<N>] returns the reference to the \code{N}th element
of \code{t}, where \code{N} is an integral constant expression.
\begin{verbatim}
tuple<int, float, char>(1, 3.14, 'a') t;
t.[index<2>] // equals 'a'
\end{verbatim}
Indexing is zero based. Index out of bounds results in a compilation error.

\subsection{Relational operators}

A relational operator \emph{op} is defined between two tuples \code{T} 
and \code{U}, iff \code{T} and \code{U} have the same number of elements,
and for all element positions, \emph{op} is defined between the element 
from \code{T} and the element from \code{U}.
\begin{verbatim}
tuple<int, float, char> t; 
tuple<int, char, int> u;
t < u; // is defined

tuple<int, int, int, int> x;
tuple<int, int, int> y; 
x < y; // not defined, different size

tuple<int, int, complex<double>, int> x;
tuple<int, int, std::string, int> y; 
x < y; // not defined, no operator< between complex<double> and std::string
\end{verbatim}

The operators \code{<}, \code{>}, \code{<=}, \code{>=} each define a 
lexicographical ordering. (JAAKKO: stick somewhere justification, std::pair,
Haskell)
The \code{operator==} is defined as the logical and of the elemenwise 
equality comparisons.
The \code{operator!=} is defined as the logical or of the
elementwise comparisons.

Each comparison operator \emph{op} is defined solely using the same
operator \emph{op} for the elementwise comparisons and makes no assumptions
about the behaviour respect to the other relational operators, or even
to whether they are defined or not.

\subsection{Input and output}

A tuple type is \concept{OutputStreamable} (JAAKKO: explain these concepts)
if each of its elements are 
\code{OutputStreamable}.
A tuple is \concept{InputStreamable} if each of its elements are 
\concept{InputStreamable}.
Note however, that in general it is not guaranteed, that a tuple written to 
an ostream can be read back from an istream to a tuple that can be
written to an ostream , and if the delimiters that are used between
the two 

Tuple objects can be written to an ostream with \code{operator<<} if
each element is 
read from an istream with \code{operator>>}.


We describe an implementation that conforms to the requirements
of this proposal.


\code{About tuples as built-in types}

Particularly, many languages consider the argument list to a function to
be implicitly a tuple object (lanXXX, langYYY).
This would be a remarkable improvement for generic programming in C++, 
making truly generic wrapping, delegating, or forwarding functions possible.
For example, the problem of not being able to inherit constructors would
cease to exist, as one could define a constructor taking any tuple, and
forward the tuple to the base class.

Another important point EIFFEL, 
Also, it is should be noted, that the programming language Eiffel does not
allow varying number of generic parameters, except for tuple tuple types.
The author is personally convinced that a built-in tuple type, with argument
list of a function being implicitely a tuple object, and a mechanism to 
(More on appendix)

\section{Text in the standard}

\section{Tuple Library}

The library provides a tuple type as 
the class template \code{tuple} that can be instantiated with any number
of arguments.
The implementation can set an upper limit for the number of arguments.
Each template argument specifies the type of an element in the \code{tuple}.
Consequently, tuples are heterogeneous fixed size collections.
of values. 

Implementation quantites:

- Number of elements in one tuple type [10].

Implementations are allowed to define the tuple template as an interface,
which inherits from some templated base class \code{T}.
If \code{T} provides all the functionality provided , and overload tuple operations (converting copy
constructors, assignments, conversion operators, etc.) for the \code{T}
templates, instead of \code{tuple} templates.


The following subclauses describe the requirements for the tuple
type.


\subsubsection{Notation}

\begin{tabular}{ll}
\code{T}, \code{U} & are tuple types\\
\code{t}, \code{u} & objects of types \code{T} and \code{U}\\
\code{tc}, \code{uc} & objects of types \code{const T} and \code{const B}\\
\code{p} & an object whose type is a potentially cv-qualified instance of \code{pair}, or whose type inherits from a potentially cv-qualified instance of \code{pair}. (JAAKKO, make this shorter)\\
\code{T$_i$} & the type of the $i$th element in \code{T}\\
\code{t$_i$} & the $i$th element of \code{t}
\end{tabular}

\noindent The notation \code{T1, T2, ..., Tn} 
stands for a comma separated list of
types which may contain any number of elements from 0 to \code{n} 
(where \code{n} <= maximum number of allowed tuple elements), 
and \code{t1, t2, ..., tn} respectively for a set of objects. 

\paragraph{Participating types}

\paragraph{Valid Expressions}

\begin{itemize}

\item Number of elements

\code{T::size} \\
\code{tuple\_traits<T>::size}\\
\returntype\ \code{const int} (integral constant expression).\\
\values\ Number of elements in \code{T}.

\item Element type

\code{T::element<N>::type}\\
\code{tuple\_traits<T>::element<N>::type}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\ 
\values\ The type of the \code{N}th element type of tuple type \code{T}.

\item Element access

\code{get<N>(t)}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\
\returntype\ \code{T::element<N>::type\&}.\\
\returns\ A reference to the \code{N}th element of \code{t}.


\code{get<N>(tc)}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\
\returntype\ \code{const T::element<N>::type\&}.\\
\returns\ A reference to the \code{N}th element of \code{tc}.\\
\notes\ Constness is shallow. If \code{T::element<N>::type} is 
X\&, the return type is X\&, not const X\&.

\item Assignment

\code{t = u}\\
\requires\ \code{T::size == U::size}. For all $i$, \\
\code{t$_i$ = u$_i$} is a valid expression.\\
\effects\ Performs \code{t$_i$ = u$_i$} for all $i$.\\
\returntype\ \code{T\&}.\\
\returns\ \code{t}.

\code{t = p}\\
\requires\ \code{T::size == 2}. \code{t$_i$ = p.first} and 
\code{t$_i$ = p.second} are valid expressions.\\
\effects\ as if implemented: \code{t$_i$ = p.first; t$_i$ = p.second;}.\\
\returntype\ \code{T\&}.\\
\returns\ \code{t}.

\item Equality comparison

\code{t == u}\\
\requires\ \code{T::size == U::size}. For all $i$, \\
\code{t$_i$ == u$_i$} is a valid expression returning a type that is
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ \code{true} iff {t$_i$ == u$_i$} for all $i$.
For any two empty tuples \code{e} and \code{f}, \code{e == f} returns \code{true}.



\item Inequality comparison

\code{t != u}\\
\requires\ \code{T::size == U::size}.
For all $i$, 
\code{t$_i$ != u$_i$} is a valid expression returning a type that is 
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ \code{true} iff {t$_i$ != u$_i$} for some $i$.
For any two empty tuples \code{e} and \code{f}, \code{e != f} returns \code{false}.

\item \code{<}, \code{<=}, \code{>}, \code{>=} comparisons

\code{t $\bullet$ u}, where \code{$\bullet$} is one of \code{<}, \code{<=}, \code{>}, 
\code{>=}\\
\requires\ \code{T::size == U::size}. For all $i$, 
\code{t$_i$ $\bullet$ u$_i$} and \code{u$_i$ $\bullet$ t$_i$} are valid expressions 
returning a type that is 
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ The result of a lexicographical comparison with \code{$\bullet$} between \code{t} and \code{u}, as if implemented:

\code{t$_i$ $\bullet$ u$_i$ || !((bool)(u$_i$ $\bullet$ t$_i$)) \&\&
                       t$_{\mathrm{tail}}$ $\bullet$ u$_{\mathrm{tail}}$}, where \code{r$_{\mathrm{tail}}$}
	is a tuple containing all but the first element of \code{r}.




\item Construction

\verb|tuple<T0, T1, ..., TN>()|\\
\requires\ Each element type can be default constructed.\\
\effects\ Default initializes each element.

\verb|tuple<T0, T1, ... TN>(t0, t1, ..., tN)|\\
\requires\ Each element type \code{Ti} type is
\concept{CopyConstructible}. JAAKKO: Are all requirements of CopyConstructible
required, probably not. Also, maybe even copy constrcution is required only
for some types that match directly. And what are references to copy constructible?
The type of each \code{ti} is convertible to \code{Ti}.\\
\effects\ Copy initializes each element with the value of the corresponding 
parameter.

\verb|tuple<T0, T1, ... TN>(u);|\\
\requires\ Each element type \code{Ti} is \concept{CopyConstructible},
(JAAKKO, see above). 
\code{u} has \code{N} elements. 
For each element index $i$, the type of \code{u$_i$} is 
convertible to \code{Ti}.\\
\effects\ Copy initializes each element $i$ with \code{u$_i$}.

\verb|tuple<T0, T1>(p)|, where \code{p} is an object of
of type \code{pair<X, Y>} (JAAKKO: or inhertis from one).\\
\requires\ \code{X} is convertible to \code{T0}, \code{Y} is convertible to 
\code{T1}.\\
\effects\ Copy initializes the first element with \code{t.first} and the 
second with \code{t.second}.

\item Input and output

\verb|os << t|, where \code{os} is an instance of \code{basic\_ostream} (JAAKKO, say somewhere, that is instance of means that is instance of or inherits
publicly from an instance of).\\
\requires\ For all $i$, \verb|os << t|\code{$_i$} is a valid expression.\\
\effects\ Inserts \code{t} into \code{os} as \code{$L$t$_1$$d$t$_2$$d$...$d$t$_n$R}, where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple manipulators.
Each element \code{t$_i$} is output by invoking \verb|os << t|\code{$_i$}.\\
\returntype\ \code{basic\_ostream}. (JAAKKO, say this differently)\\
\returns\ \code{os}.

\verb|is >> t|, where \code{is} is an instance of \code|basic\_istream| (JAAKKO, say somewhere, that is instance of means that is instance of or inherits
publicly from an instance of).\\
\requires\ For all $i$, \verb|is >> t|\code{$_i$} is a valid expression.\\
\effects\ Extracts a tuple of the form \code{$L$t$_1$$d$t$_2$$d$...$d$t$_n$R},
where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple manipulators.
Each element \code{t$_i$} is extracted by invoking \verb|is >> t|\code{$_i$}.
If bad input is encountered, calls \code{is.set\_state(ios::failbit)} (which
may throw \code{ios::failure} (27.4.4.3).\\
\returntype\ \code{basic\_istream}. (JAAKKO, say this differently)\\
\returns \code{is}.

\item Manipulators

The type designated \emph{tuple\_manip} in the following function descriptions
is implementation-specified and may be
different for each function.

\emph{tuple\_manip} \code{tuple\_open(char\_type c)}\\
\emph{tuple\_manip} \code{tuple\_close(char\_type c)}\\
\emph{tuple\_manip} \code{tuple\_delimiter(char\_type c)}\\
\returns\ Each of these functions returns an object \code{s} of unspecified 
type such that if \code{out} is an 
instance of \code{basic\_ostream<charT,traits>}, \code{in} is an instance of
\code{basic\_istream<charT,traits>} and \code{c} has type \code{charT},
then expression \verb|out << s| (respectively \verb|in >> s|) 
sets \code{c} to be
the opening, closing, or delimiter character (depending on the manipulator
function called) to be used when writing tuples into \code{out} (respectively
reading extracting tuples from \code{in}).\\
\notes\ Implementation is not required to support these manipulators for 
streams with \code{sizeof(charT) > sizeof(long)}; if not supported,
\verb|out << s| and \verb|in >> s| are required to fail at compile time if
\code{out} are \code{in} are such streams.

\item Functions for helping in tuple construction

The library provides class template \code{any\_holder} that can hold
objects or references of any type. 
Reference types wrapped in \code{any\_holder} can be passed by copy, and
as const reference, whithout affecting the constness of the wrapped object.
Two template functions, \code{ref} and \code{cref} are provided to create
\code{any\_holder} objects.
The observable behaviour of \code{any\_holder}, \code{ref} and \code{cref}
must be as if implemented:
\begin{verbatim}
template <class T>
class any_holder {
  T data;
//  typedef typename add_reference<typename add_const<T>::type>::type par_t;
  typedef const T& par_t;
public:
  operator T() { return data; }
  T unwrap() { return data; }

  explicit any_holder(par_t t) : data(t) {}
};

template <class T> inline any_holder<T&> ref(T& t) { 
  return any_holder<T&>(t); 
}

template <class T> inline any_holder<const T&> cref(const T& t) { 
  return any_holder<const T&>(t); 
}
\end{verbatim}

\code{make\_tuple(t1, t2, ..., tn)}\\
\returntype\ \code{tuple<T1, T2, ..., TN>}, where 
if \code{Vi} is the non-reference type of \code{ti}
\begin{itemize}
\item \code{Vi} is an array type, then \code{Ti} is a reference \code{const Vi}.(JAAKKO. can one add const to an array type)
\item if the cv-unqualified type of \code{Vi} is \code{any\_holder<X>},
then \code{Ti} is \code{X}.
\item otherwise \code{Ti} is \code{remove\_const<Vi>::type}.
\end{itemize}
\example\ \verb|int i; float j; make_tuple(1, "C++", ref(i), cref(j))| creates
a tuple of type \verb|tuple<int, const char (&) [4], int&, const float&>|.
\notes\ To construct a tuple which contains a reference to a function, the 
function reference must be wrapped inside \code{ref}.

\code{tie(t1, t2, ..., tn)}\\
\effects\ As if implemented:
\begin{verbatim}
template<class T1, class T2, ..., class TN>
tuple<T1&, T2&, ..., TN&> tie(T1& t1, T2& t2, ..., TN& tn) {
  return tuple<T1&, T2&, ..., TN&>(t1, t2, ..., tn); 
}
\end{verbatim}
%
for each \code{N} from 0 to the maximum number of allowed tuple elements.

The library provides an object
\code{ignore} of some implementation-specified type \emph{swallow\_assignment}.

\code{ignore = k}, where \code{k} referes to an object of arbitrary type.\\
\effects\ No effect.\\
\returntype\ \emph{swallow\_assignment}\code{\&}\\
\notes\ \code{k} may not be a reference to a function, unless rule XXX 
is changed.

\example\ \code{tie} functions let one create tuples that unpacks another 
tuple object into variables. \code{ignore} can be used for elements that
are not needed:
\begin{verbatim}
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, , 3.14, "C++");
// i == 42, s == "C++";
\end{verbatim}
\end{itemize}



\end{document}

\section{Discussion about design}

\subsection{About valid element types\label{about_valid_element_types}}

The proposed requirements state, that there are no restrictions on the types
of tuple elements, if the program contains no construction invocations 
for the tuple type.
For example, \code{void} and \code{int()()} are valid C++ types, but 
objects of these types can never be created. 
Hence, \code{tuple<void, int()()>} is a valid tuple type but obviously an
object of this type cannot be constructed.

A straightforward implementation, where the type of a template
parameter is a type of a member variable, does not fullfil the above
restriction. The types of the member variables are checked when the template 
is instantiated, and \code{void} and function types are rejected as member
types, even though an object is never constructed.

The way to cope with this issue is to transform each member through
a traits class, wrapping \code{void} and function types to something 
that can be a member variable, but cannot be constructed.

This means extra clutter in the code implementing tuple types, but
we find the feature important for uniformness. 
Otherwise, tuple types would impose a restriction, that does not exist
for the element types.



- Miksi assignment riittää paireista tupliin
- Mikä on tuple_size:n return type


The tuple type is impelemented as an interface template \code{tuple} that
can take up to $n$ (10 in the reference implementation) template arguments.
It is very tedious to overload functions for such a verbose type.
Consequently, the \code{tuple} interface class inherits from instantiations
of another type (\code{cons}) which represents the tuple element as a 
\emph{cons list}.
Comparison operators, streaming operators and element accessor functions all 
operate on the cons list representation.

We propose this representation be standardized as well, to give end programmers
a convenient way to overload functions for tuple types. 



The library provides traits classes for querying 
properties of tuples and their elements:

\begin{verbatim}
tuple_size<T>::value
\end{verbatim}
\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}. \\
\values\ \code{const int} holding the number of elements in the cons list \code{T}.

\begin{verbatim}
tuple_element<N, T>::type
\end{verbatim}
\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}. \\
$0 \leq $ \code{N} $ < $ \code{tuple\_size<T>::value}.
\values\ The type of the \code{N}th element in \code{T}.

\begin{verbatim}
template <int N, class H, class T> rt? get(cons<H, T>&);
template <int N, class H, class T> rt? get(const cons<H, T>&);
\end{verbatim}

\begin{verbatim}
inline bool operator==(const null_type&, const null_type&);
inline bool operator>=(const null_type&, const null_type&);
inline bool operator<=(const null_type&, const null_type&);
\end{verbatim}
\returns\ \code{true}.

\begin{verbatim}
inline bool operator!=(const null_type&, const null_type&);
inline bool operator<(const null_type&, const null_type&);
inline bool operator>(const null_type&, const null_type&);
\end{verbatim}
\returns\ \code{false}.

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator==(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}
\returns\ \code{true} if all elementwise comparisons are true.
\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator!=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator<(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator>(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator<=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator>=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}






\begin{verbatim}
cons(const typename remove_volatile<head_type>::type& h, 
     const tail_type& t);
\end{verbatim}
\requires{All elements are \concept{CopyConstructible}}.
\effects\ Initializes \code{head\_} with \code{h}
and \code{tail\_} with \code{t}.\\
\notes\ 
Unless \code{head\_type} is a non-const reference type, it is allowed 
to call the constructor with a temporary as the first argument.
When binding temporaries to references, the reference must
be to a non-volatile and const type (8.5.3 (5)). Thus \code{volatile}
is removed and \code{const} added. Reference types stay intact.


\begin{verbatim}
template <class H2, class T2> cons(const cons<H2, T2>& u);
\end{verbatim}

\effects\ Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.


\begin{verbatim}
template <class HT2, class TT2> cons& operator=(const cons<HT2, TT2>& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}


\begin{verbatim}
cons& operator=(const cons& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}\\
\notes\ Default assignment operator is illformed if a class contains
member variables of reference types (12.8 (12)). 
Therefore an explicit definition is needed.

\begin{verbatim}
template <class T1, class T2> cons& operator=(const std::pair<T1, T2>& u);
\end{verbatim}
\requires\ \code{tuple\_size<cons> == 2} (ref????).\\
\effects\ As if implemented: 
\code{*this.head\_ = u.first; *this.tail\_.head\_ = u.second;}\\
\returns\ \code{*this}


\returns\ Reference to \code{head\_}.\\
\notes\ Constness is shallow. If \code{head\_type} is a non-const reference 
type, returns a non-const reference.




\begin{tabular}{lll}

\code{T} and \code{U} are types to be supplied by a C++ program 
intantiating a template, \code{t} is a value of type \code{T}, 
\code{u} a value of type \code{U}, \code{tc} and \code{uc} are 
value of types \code{const T} and \code{const U} respectively.




