\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}


%\usepackage[finnish]{babel}

\usepackage{fullpage}

\usepackage{url}
\usepackage{alltt}



\newcommand{\cccomment}[1]{\textrm{\textit{#1}}}

\newcommand{\effects}{\noindent \textbf{Effects:}}
\newcommand{\returns}{\noindent \textbf{Returns:}}
\newcommand{\returntype}{\noindent \textbf{Return type:}}
\newcommand{\requires}{\noindent \textbf{Requires:}}
\newcommand{\notes}{\noindent \textbf{Notes:}}
\newcommand{\values}{\noindent \textbf{Value:}}
\newcommand{\example}{\noindent \textbf{Example:}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\req}[1]{\noindent \textbf{#1}}

\newcommand{\concept}[1]{\textsf{#1}}

\author{Jaakko Järvi\\
Indiana University\\
Pervasive Technology Laboratories\\
Bloomington, IN\\
{\em jajarvi@cs.indiana.edu}}


\title{Proposal for adding tuple types into the standard library\\ \large{Programming Language C++}\\ \large{Document no: N1403=02-0061}}


\begin{document}
\maketitle

\markboth{Doc. no: N1403=02-0061}{Doc. no: N1403=02-0061}

\pagestyle{myheadings}


\section{Motivation}

Tuple types exist in several programming languages, such as Haskell, 
ML, Python and Eiffel, to name a few. 
Tuples are fixed-size heterogeneous 
containers. They are a general-purpose utility, 
adding to the expressiveness of the language. Some examples of 
common uses for tuple types are:
\begin{itemize}
\item Return types for functions that need to have more than one return type.
\item Grouping related types or objects (such as entries in parameter lists) 
into single entities.
\item Simultaneous assignment of multiple values.
\end{itemize}

This proposal describes tuple types for C++. 
The standard library provides the \code{pair}
template which is being used throughout the standard library, demonstrating 
the usefulness of tuple-like constructs.
The proposed tuple type is basically a generalization of the \code{pair} 
template from two to an arbitrary number of elements.
In addition to the features and functionality of pairs, 
the proposed tuple types:
\begin{itemize}
\item Support a wider range 
of element types (e.g. reference types).
\item Support input from and output to streams, customizable
with specific manipulators.
\item Provide a mechanism for `unpacking' tuple elements into separate variables.
\end{itemize}

\section{Impact on the standard}

All features described in this document can be implemented in a library,
without requiring any core language changes.
However, the implementation would benefit from a set of core language changes:
\begin{itemize}
\item Adding support for variable-length template argument lists.
\item Making a reference to a reference to some type \code{T} equal to 
a reference to \code{T} (core language issue 106).
\item Allowing default template arguments for function
templates (core language issue 226).
\item Ignoring cv-qualifiers that are added to function types (core language issue 295).
\item Adding support for templated typedefs.
\end{itemize}

The proposal is written in such a way that it leaves 
room for a built-in tuple type, or for a tuple template with special
support from the compiler, which we see as being worth considering.
Compared to built-in tuple types in other languages,
a library solution still falls short in some aspects.
For instance, in the programming language Python, 
the function argument list is implicitly a tuple.
This is a feature that cannot be added to C++ as a library, but
would be most useful.\footnote{Truly generic forwarding functions
that could take any number of parameters would be supported. For example, one constructor 
definition in a derived class could cover a large set of base class 
constructors with different arities and argument types.}


The concrete additions and changes to the standard are:
\begin{itemize}
\item A new section describing the requirements for the tuple template.
\item Backwards-compatible changes to \code{pair} to allow pairs to act
as tuples.
\item A utility class and two utility function templates to be used in passing
reference arguments through a pass-by-copy interface.
These templates have uses outside of tuples we suggest then to be 
included in section 20.2 (Utility components).
\end{itemize}

We propose a new new standard header \code{<tuple>}.
Operators for reading tuples from a stream and writing tuples to
a stream introduce a dependency to \code{<istream>} and \code{<ostream>},
so it is a quality-of-implementation issue to not include definitions
from these headers unnecessarily.


\section{Tuples in a nutshell}

The purpose of this section is to give an informal overview of the 
features that the tuple types provide.
The feature set is largely based on the Boost Tuple 
Library~\cite{cit:boost_tuple_library:01,jarvi:01:cuj_tuples}.

\subsection{Defining tuple types}

The \code{tuple} template can be instantiated with any number of arguments
from 0 to some predefined upper limit. In the Boost Tuple library, this limit is 10.
The argument types can be any valid C++ types.
For example:
\begin{verbatim}
typedef tuple<A, const B, volatile C, const volatile D> t1;
typedef tuple<int, int&, const int&, const volatile int&> t2;
typedef tuple<void, int()(int)> t3;
\end{verbatim}
Note that even types of which no objects can be created (cf. \code{void}, \code{int()(int)}), are valid tuple elements.
Naturally, an object of a tuple type with such an element type cannot 
be constructed. 

\subsection{Constructing tuples}

An $n$-element tuple has a default constructor, 
a constructor with $n$ parameters, 
a copy constructor and a \emph{converting copy constructor}.
By converting copy constructor we refer to a constructor that 
can construct a tuple from another tuple, as long as the type of each element
of the source tuple is convertible to the type of the corresponding 
element of the target tuple.
%
The types of the elements restrict which constructors can be used:
\begin{itemize}
\item If an $n$-element tuple is constructed with a constructor taking 
0 elements, all elements must be default constructible.
For example:
\begin{alltt}
tuple<int, float> a; // \cccomment{ok}
class no_default_constructor \{ no_default_constructor(); \};
tuple<int, no_default_constructor, float> b; // \cccomment{error}
tuple<int, int&> c; // \cccomment{error, no default construction for references}
\end{alltt}


\item If an $n$-element tuple is constructed with a constructor taking 
$n$ elements, all elements must be copy constructible and convertible
(default initializable) from the corresponding argument.
For example:
\begin{alltt}
tuple<int, const int, std::string>(1, 'a', "Hi")
tuple<int, std::string>(1, 2); // \cccomment{error}
\end{alltt}

\item If an $n$-element tuple is constructed with the converting copy 
constructor, each element type of the constructed tuple type must
be convertible from the corresponding element type
of the argument. 
\begin{alltt}
tuple<char, int, const char(&)[3]> t1('a', 1, "Hi");
tuple<int, float, std::string> t2 = t1; // \cccomment{ok}
\end{alltt}
%
Construction works from \code{std::pair} as well.
For example:
%
\begin{alltt}
tuple<int, int> t3 = make_pair('a', 1); // \cccomment{ok}
\end{alltt}

\end{itemize}

\subsection{\code{make\_tuple}}

Tuples can also be constructed using the \code{make\_tuple} 
(cf. \code{make\_pair}) utility function templates. 
This makes the construction more convenient, saving the programmer 
from explicitly specifying the element types:
%
\begin{verbatim}
tuple<int, int, double> add_multiply_divide(int a, int b) {
  return make_tuple(a+b, a*b, double(a)/double(b));
}
\end{verbatim}
%
By default, the element types are plain non-reference types. 
E.g., the \code{make\_tuple} invocation below creates a tuple of type
\code{tuple<A, B>}:
\begin{verbatim}
void foo(const A& a, B& b) { 
  ...
  make_tuple(a, b);
  ...
}
\end{verbatim}
%
This default behavior can be changed with to utility functions \code{ref} 
and \code{cref}.
An argument wrapped with \code{ref} will cause the element type to be 
a reference to the argument type, and \code{cref} will similarly cause the element type to be a reference to the const argument type. 
For example:
%
\begin{alltt}
A a; B b; const A ca = a;
make_tuple(cref(a), b);      // \cccomment{constructs tuple<const A&, B>(a, b)}
make_tuple(ref(a), b);       // \cccomment{constructs tuple<A&, B>(a, b)}
make_tuple(ref(a), cref(b)); // \cccomment{constructs tuple<A&, const B&>(a, b)}
make_tuple(cref(ca));        // \cccomment{constructs tuple<const A&>(ca)}
make_tuple(ref(ca));         // \cccomment{constructs tuple<const A&>(ca)}
\end{alltt}

Note that \code{make\_tuple} cannot be made to accept references to function 
types without the \code{ref} wrapper, unless core language issue 295 
is resolved.

\subsection{Assignment}

The assignment operation is defined as element-wise assignment.
Consequently, two tuples are assignable as long as they are
element-wise assignable. For example:
%
\begin{alltt}
tuple<char, int, const char(&)[3]> t1('a', 1, "Hi");
tuple<int, float, std::string> t2;
t2 = t1; // \cccomment{ok}
\end{alltt}
%
Analogously to the converting copy constructor, assignment 
is defined from pairs as well.


\subsection{The \code{tie} function templates}

The \code{tie} functions are a short-hand notation for creating tuples where
all element types are references. 
A \code{tie} call corresponds to an invocation of \code{make\_tuple} where 
all arguments have been wrapped with \code{ref}. 
For example, the \code{tie} and \code{make\_tuple} invocations below 
both return
the same type of tuple object, namely \verb|tuple<int&, char&, double&>|:
\begin{verbatim}
int i; char c; double d; 
tie(i, c, d);
make_tuple(ref(i), ref(c), ref(d)); 
\end{verbatim}
%
A tuple that contains non-const references as elements can be used to 
`unpack' another tuple into variables. 
For example:
%
\begin{verbatim}
int i; char c; double d; 
tie(i, c, d) = make_tuple(1, 'a', 5.5);
\end{verbatim}
After the assignment, \code{i == 1}, \code{c == 'a'} and \code{d == 5.5}.
A tuple unpacking operation like this is found, for example, in ML and Python. 
It is convenient when calling functions which return tuples.


\subsubsection{Ignore}

The library provides an object called \code{ignore} which allows one 
to ignore elements in an assignment to a tuple. 
Any assignment to \code{ignore} is a no-operation.
For example:
\begin{verbatim}
char c;
tie(ignore, c) = make_tuple(1, 'a');
\end{verbatim}
After this assignment, \code{c == 'a'}.

\subsection{Number of elements}

The number of elements in a tuple type is accessible as a compile-time 
constant:
\begin{alltt}
tuple_size<tuple<int, int, int, int> >::value; // \cccomment{equals 4}
\end{alltt}

\subsection{Element type}

The type of the \code{N}th
element of a tuple type is accessed using 
the \code{tuple\_element} template:
\begin{alltt}
tuple_element<2, tuple<int, char, float, double> >::type // \cccomment{float}
\end{alltt}
%
Indexing is zero-based. 
The index must be an integral constant expression
and using an index that is out of bounds results in a compile time error.

\subsection{Element access}

Let \code{t} be a tuple object. 
The expression \code{get<N>(t)} returns a reference to the \code{N}th 
element of \code{t}, where \code{N} is an integral constant expression.
\begin{alltt}
tuple<int, float, char>(1, 3.14, 'a') t;
get<2>(t); // \cccomment{equals 'a'}
\end{alltt}
%
Indexing is zero-based. 
Using an index that is out of bounds results in a compilation error.

\subsection{Relational operators}

Tuples implement the operators \code{==}, \code{!=}, \code{<}, \code{>}, 
\code{<=} and \code{>=} using the corresponding operators on elements.
This means that if any of these operators is defined between all elements of 
two tuples, the same operator is defined between the tuples as well. 

The \code{operator==} is defined as the logical AND of the element-wise 
equality comparisons.
The \code{operator!=} is defined as the logical OR of the
element-wise inequality comparisons.
The operators \code{<}, \code{>}, \code{<=} and \code{>=} each define a 
lexicographical ordering. 
An attempt to compare two tuples of different lengths results in 
a compile-time error.
The comparison operators are ``short-circuited'': elementary comparisons 
start from the first elements and are performed only until the result is known.
Elements after that are not accessed.
For example: 


\begin{alltt}
tuple<int, float, char> t(1, 2, 'a'); 
tuple<int, char, int> u(1, 1, 1000);
t < u; // \cccomment{ok, false}

tuple<int, int, int, int> x;
tuple<int, int, int> y; 
x < y; // \cccomment{error, different sizes}

tuple<int, int, complex<double>, int> x;
tuple<int, int, string, int> y; 
x < y; // \cccomment{error, no operator< between complex<double> and string}
\end{alltt}


\subsection{Input and output}

The library overloads the streaming operators \verb|<<| and \verb|>>| for 
tuples. 
Output is implemented by invoking \verb|operator<<| for each element,
and input similarly with invocations of \verb|operator>>|.
When writing a tuple to a stream, opening and closing 
characters are written around the body of the tuple.
Additionally, a delimiter character is written between each 
two consecutive elements.
Similarly, the opening, closing and delimiter characters are expected to be 
present when extracting
a tuple from an input stream.
The default delimiter between the elements is a space, and the default opening
and closing characters are the parentheses.
For example:
\begin{verbatim}
cout << make_tuple(1, 'a', "C++");
\end{verbatim}
outputs \code{(1 a C++)}.

The library defines three formatting manipulators for tuples, \code{tuple\_\-open}, 
\code{tuple\_close} and \code{tuple\_\-delimiter} to change, respectively, 
the opening, closing and delimiter characters for a particular stream.
For example:
\begin{verbatim}
cout << tuple_open('[') << tuple_close(']') 
     << tuple_delimiter(',') 
     << make_tuple(1, 'a', "C++");
\end{verbatim}
outputs the same tuple as: \code{[1,a,C++]}.

Note that in general it is not guaranteed that a tuple written to 
a stream can be extracted back to a tuple of the same type, since the 
streamed tuple representation may not be unambiguously parseable.
This is true, for instance, for tuples with \code{string} or C-style string 
element types.

\subsection{Performance}

Based on the experience with the Boost Tuple library, 
it is reasonable to expect an optimizing compiler to eliminate any extra cost 
of using tuples compared to using hand-written tuple-like classes.
Inlining and copy propagation are the optimizations required to attain 
this goal.

Concretely, accessing tuple members should be as efficient as accessing
a member variable of a class.
Further, constructing a tuple should have no other cost than the cost
of constructing the elements as separate objects.
The same should be true for assignment.


\part*{Text in the standard}

Text enclosed with brackets and typeset in sans serif is
a comment, not proposed standard text \textsf{[This is a comment]}.

\section{Annex B: Implementation quantities}

\textsf{[Add to the list of implementation quantities (which specifies the
recommended minima for implementation quantities).]}

\medskip 

--- Number of elements in one tuple type [10].

\medskip


\section{Tuple library}

This clause describes the tuple library that provides a tuple type as 
the class template \code{tuple} that can be instantiated with any number
of arguments.
An implementation can set an upper limit for the number of arguments.
The minimum value for this implementation
quantity is defined in Annex B.
Each template argument specifies the type of an element in the \code{tuple}.
Consequently, tuples are heterogeneous, fixed-size collections of values. 



\subsubsection*{Header \code{<tuple>} synopsis}

\noindent\hspace{\parindent}  \begin{minipage}{10.5cm} \begin{alltt}
template <class T1 = \textrm{\emph{implementation-defined}}, 
          class T2 = \textrm{\emph{implementation-defined}}, 
          ..., 
          class TM = \textrm{\emph{implementation-defined}}> class tuple;

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator==(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator!=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator<(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator<=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator>(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator>=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template <class T> class tuple_size;

template <int I, class T> class tuple_element;

template <int I, class T1, class T2, ..., class TN> 
\textrm{\emph{RI}} get(tuple<T1, T2, ..., TN>&);

template <int I, class T1, class T2, ..., class TN> 
\textrm{\emph{PI}} get(const tuple<T1, T2, ..., TN>&);

template<class T1, class T2, ..., class TN>
tuple<\textrm{\emph{V1}}, \textrm{\emph{V2}}, ..., \textrm{\emph{VN}}> 
make_tuple(const T1&, const T2& , ..., const TN&); 

template<class T1, class T2, ..., class TN>
tuple<T1&, T2&, ..., TN&> tie(T1&, T2& , ..., TN&); 

template<class CharType, class CharTrait, class T1, class T2, ..., class TN>
basic_ostream<CharType, CharTrait>& 
operator<<(basic_ostream<CharType, CharTrait>&, const tuple<T1, T2, ..., TN>&);

template<class CharType, class CharTrait, class T1, class T2, ..., class TN>
basic_istream<CharType, CharTrait>& 
operator>>(basic_istream<CharType, CharTrait>&, tuple<T1, T2, ..., TN>&);

\textrm{\emph{tuple_manip1}} tuple_open(\textrm{\emph{char\_type}} c);
\textrm{\emph{tuple_manip2}} tuple_close(\textrm{\emph{char\_type}} c);
\textrm{\emph{tuple_manip3}} tuple_delimiter(\textrm{\emph{char\_type}} c);
\end{alltt}
\end{minipage}

\medskip



\subsubsection*{Class template \code{tuple}}

\code{M} is used to denote the implementation-defined number of template type parameters to the tuple class template, and 
\code{N} is used to denote the number of template arguments specified in an instantiation.

\medskip 

\noindent 
[\emph{Example:} Given the instantiation \verb|tuple<int, float, char>|, \code{N} is 3.
--\emph{end example}]

\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{alltt}
template <class T1 = \textrm{\emph{implementation-defined}}, 
          class T2 = \textrm{\emph{implementation-defined}}, 
          ..., 
          class TM = \textrm{\emph{implementation-defined}}> class tuple \{
public:
  tuple();
  explicit tuple(P1, P2, ..., PN); // iff N > 0

  tuple(const tuple&);

  template <class U1, class U2, ..., class UN> 
  tuple(const tuple<U1, U2, ..., UN>&);

  template <class U1, class U2>
  tuple(const pair<U1, U2>&);

  tuple& operator=(const tuple&);

  template <class U1, class U2, ..., class UN> 
  tuple& operator=(const tuple<U1, U2, ..., UN>&);

  template <class U1, class U2>
  tuple& operator=(const pair<U1, U2>&);
\};
\end{alltt}
\end{minipage}

\medskip



\subsubsection*{Construction}

\noindent \hspace{\parindent} \verb|tuple();|

\medskip 
\req{Requires:} Each tuple element type \code{Ti} can be default constructed.\\
\req{Effects:} Default initializes each element.

\bigskip 

\noindent \hspace{\parindent} \verb|tuple(P1, P2, ..., PN);|

\medskip 

\noindent Where, if \code{Ti} is a reference type then \code{Pi} is \code{Ti}, otherwise
\code{Pi} is \code{const Ti\&}.\\
\req{Requires:} Each tuple element type \code{Ti} is
copy constructible.\\ 
\req{Effects:} Copy initializes each element with the value of the 
corresponding parameter.

\bigskip 

\noindent \hspace{\parindent} \verb|tuple(const tuple& u);|

\medskip

\req{Requires:} all types \code{Ti} shall be copy constructible.\\
\req{Effects:} Copy constructs each element of \code{*this} with the 
corresponding element of \code{u}.

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template <class U1, class U2, ..., class UN> 
tuple(const tuple<U1, U2, ..., UN>& u);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} Each type \code{Ti} shall be constructible from the corresponding type \code{Ui}.\\
\req{Effects:} Constructs each element of \code{*this} with the 
corresponding element of \code{u}.

\medskip 

\noindent \textsf[ In an implementation where one template definition serves for
many different values for \code{N}, enable\_if can be used to 
make the converting constructor and assignment operator exist only in the cases where
the source and target have the same number of elements.
Another way of achieving this is adding an extra integral template parameter
which defaults to \code{N} (more precisely, a metafunction that computes \code{N}), and then defining the
converting copy constructor and assignment only for tuples where the extra parameter in 
the source is \code{N}.]

\bigskip 


\noindent\hspace{\parindent}
\verb|template <class U1, class U2> tuple(const pair<U1, U2>& u);|

\medskip 

\req{Requires:} \code{T1} shall be constructible from \code{U1},
\code{T2} shall be constructible from \code{U2}.
\code{N == 2}.\\
\req{Effects:} Constructs the first element with \code{u.first} and the
second element with \code{u.second}.

\bigskip

\noindent\hspace{\parindent}
\verb|tuple& operator=(const tuple& u);|

\medskip

\req{Requires:} All types \code{Ti} are assignable.\\
\req{Effects:} Assigns each element of \code{u} to the corresponding 
element of \code{*this}.\\
\req{Returns:} \code{*this}

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template <class U1, class U2, ..., class UN> 
tuple& operator=(const tuple<U1, U2, ..., UN>& u);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} Each type \code{Ti} shall be assignable from the 
corresponding type \code{Ui}.\\
\req{Effects:} Assigns each element of \code{u} to the corresponding
 element of \code{*this}.\\
\req{Returns:} \code{*this}

\bigskip 


\noindent\hspace{\parindent}
\verb|template <class U1, class U2> tuple& operator=(const pair<U1, U2>& u);|

\medskip 

\req{Requires:} \code{T1} shall be assignable from \code{U1},
\code{T2} shall be assignable from \code{U2}.
\code{N == 2}.\\
\req{Effects:} Assigns \code{u.first} to the first element of \code{*this}
and \code{u.second} to the second element of \code{*this}.\\
\req{Returns:} \code{*this}

\medskip



\noindent
\begin{sf}
[ There seem to exist (rare) conditions where the converting copy constructor
is a better match than the element-wise construction, even though the user
might intend differently.
An example of this is if one is constructing a one-element tuple where 
the element type is another tuple type \code{T} and if 
the parameter passed to the constructor is not of type \code{T}, but
rather a tuple type that is convertible to \code{T}.
The effect of the converting copy construction is most likely the same
as the effect of the element-wise construction would have been.
However, it it possible to compare the 'nesting depths' of the source and
target tuples and decide to select the element-wise constructor if the 
source nesting depth is smaller than the target nesting-depth. 
This can be accomplished using an enable\_if template or other tools for
constrained templates.
]
\end{sf}


\subsubsection*{Tuple creation functions}

\noindent\hspace{\parindent} 
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TN>
tuple<V1, V2, ..., VN> 
make_tuple(const T1& t1, const T2& t2, ..., const TN& tn); 
\end{verbatim}
\end{minipage}

\medskip

\noindent where \code{Vi} is \code{X\&}, if the cv-unqualified type \code{Ti} is \code{reference\_wrapper<X>}, otherwise \code{Vi} is \code{Ti}.

\medskip 

\req{Returns:} \code{tuple<V1, V2, ..., VN>(t1, t2, ..., tn)}.\\
\req{Notes:} The \code{make\_tuple} function template must be implemented
for each different number of arguments from 0 to the maximum number of allowed tuple elements.

\medskip 

\noindent 
[\emph{Example:}

\medskip 

\noindent\hspace{\parindent}
\begin{minipage}{10.5cm}
\begin{verbatim}
int i; float j; 
make_tuple(1, ref(i), cref(j))
\end{verbatim}
\end{minipage}

\medskip 

\noindent creates a tuple of type 

\medskip 

\noindent\hspace{\parindent}  
\verb|tuple<int, int&, const float&>|

\medskip 

\noindent --\emph{end example}]

\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TN>
tuple<T1&, T2&, ..., TN> tie(T1& t1, T2& t2, ..., TN& tn); 
\end{verbatim}
\end{minipage}

\medskip  

\req{Returns:} \verb|tuple<T1&, T2&, ..., TN&>(t1, t2, ..., tn)|\\
\req{Notes:} The \code{tie} function template must be implemented
for each different number of arguments from 0 to the maximum number of allowed tuple elements.

\medskip

\noindent 
[\emph{Example:}

\medskip 

\noindent \code{tie} functions allow one to create tuples that unpack 
tuples into variables. \code{ignore} can be used for elements that
are not needed:

\medskip

\noindent\hspace{\parindent} 
\begin{minipage}{10.5cm}
\begin{alltt}
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// \cccomment{i == 42, s == "C++";}
\end{alltt}
\end{minipage}

\medskip 

\noindent --\emph{end example}]

\subsubsection*{Valid expressions for tuple types}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
tuple_size<T>::value
\end{verbatim}
\end{minipage}

\medskip

\req{Requires:} \code{T} is an instantiation of class template tuple. \\
\req{Type:} integral constant expression.\\
\req{Value:} Number of elements in \code{T}. 


\bigskip

\noindent\hspace{\parindent}  
\code{tuple\_element<I, T>::type}

\medskip 

\req{Requires:} 0 $\le$ \code{I} $<$ \code{tuple\_size<T>::value}.
The program is ill-formed if \code{I} is out of bounds. \\ 
\req{Value:} The type of the \code{I}th element of \code{T}, where
indexing is zero-based.


\subsubsection*{Element access}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template <int I, class T1, class T2, ..., class TN> 
RI get(tuple<T1, T2, ..., TN>& t);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} 0 $\le$ \code{I} $<$ \code{N}.
The program is ill-formed if \code{I} is out of bounds.\\
\req{Return type:} \code{RI}. If \code{TI} is a reference type, then \code{RI}
is \code{TI}, otherwise \code{RI} is \code{TI\&}.\\
\req{Returns:} A reference to the \code{I}th element of \code{t}, where
indexing is zero-based.

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template <int I, class T1, class T2, ..., class TN> 
PI get(const tuple<T1, T2, ..., TN>& t);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} 0 $\le$ \code{I} $<$ \code{N}.
The program is ill-formed if \code{I} is out of bounds.\\
\req{Return type:} \code{PI}. If \code{TI} is a reference type, then \code{PI}
is \code{TI}, otherwise \code{PI} is \code{const TI\&}.\\
\req{Returns:} A const reference to the \code{I}th element of \code{t}, where
indexing is zero-based.

\medskip  

\noindent \textsf{[ Constness is shallow. If \code{TI} is some
reference type \code{X\&}, the return type is \code{X\&}, not \code{const X\&}.
However, if the element type is non-reference type \code{T}, the return
type is \code{const T\&}.
This is consistent with how constness is defined to work 
for member variables of reference type.]}

\medskip  

\begin{sf}
\noindent 
[ Implementing \code{get} as a member function of tuple, would require using
the \code{template} keyword in invocations where the type of the tuple object 
is dependent on a template parameter. For example: \verb|t.template get<1>();|
]
\end{sf}



\subsubsection*{Equality and inequality comparisons}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator==(const tuple<T1, T2, ..., TM>& t, 
                const tuple<U1, U2, ..., UM>& u);
\end{verbatim}
\end{minipage}


\medskip 

\req{Requires:} \code{tuple\_size<tuple<T1, T2, ..., TM> >::value == tuple\_size<tuple<U1, U2, ..., UM> >::value == N}. 
For all \code{i}, where \code{0 <= i < N},
\code{get<i>(t) == get<i>(u)} is a valid expression returning a type that is
convertible to \code{bool}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} \code{true} iff \code{get<i>(t) == get<i>(u)} for all \code{i}.
For any two zero-length tuples \code{e} and \code{f}, \verb|e == f| returns \code{true}.\\
\req{Effects:} The elementary comparisons are performed in order from the zeroth index upwards. 
No comparisons or element accesses are performed after the first equality comparison that evaluates to \code{false}.

\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator!=(const tuple<T1, T2, ..., TM>& t, 
                const tuple<U1, U2, ..., UM>& u);
\end{verbatim}
\end{minipage}


\medskip 

\req{Requires:} \code{tuple\_size<tuple<T1, T2, ..., TM> >::value == tuple\_size<tuple<U1, U2, ..., UM> >::value == N}. 
For all \code{i}, where \code{0 <= i < N},
\code{get<i>(t) != get<i>(u)} is a valid expression returning a type that is
convertible to \code{bool}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} \code{true} iff \code{get<i>(t) != get<i>(u)} for any \code{i}.
For any two zero-length tuples \code{e} and \code{f}, \verb|e != f| returns \code{false}.\\
\req{Effects:} The elementary comparisons are performed in order from the zeroth index upwards. 
No comparisons or element accesses are performed after the first inequality comparison that evaluates to \code{true}.

\bigskip 

\subsubsection*{\code{<}, \code{>} comparisons}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TN, class U1, class U2, ..., class UN>
bool operator<(const tuple<T1, T2, ..., TN>&, const tuple<U1, U2, ..., UN>&);

template<class T1, class T2, ..., class TN, class U1, class U2, ..., class UN>
bool operator>(const tuple<T1, T2, ..., TN>&, const tuple<U1, U2, ..., UN>&);
\end{verbatim}
\end{minipage}

\medskip


\req{Requires:} \code{tuple\_size<tuple<T1, T2, ..., TM> >::value == tuple\_size<tuple<U1, U2, ..., UM> >::value == N}. 
For all \code{i}, where \code{0 <= i < N},
\code{get<i>(t) \code{$\odot$} get<i>(u)} is a valid expression returning a type that is
convertible to \code{bool}, where \code{$\odot$} is either \code{<} or \code{>}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} The result of a lexicographical comparison with \code{$\odot$} between \code{t} and \code{u}, defined equivalently to:

\code{(bool)(get<0>(t) $\odot$ get<0>(u)) || !((bool)(get<0>(u) $\odot$ get<0>(t)) \&\&
 t$_{\mathrm{tail}}$ $\odot$ u$_{\mathrm{tail}}$}, \\
where \code{r$_{\mathrm{tail}}$}
        for some tuple \code{r} is a tuple containing all but the first element of \code{r}. 
For any two zero-length tuples \code{e} and \code{f}, \code{e $\odot$ f} returns \code{false}.


\bigskip 

\subsubsection*{\code{<=} and \code{>=} comparisons}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TN, class U1, class U2, ..., class UN>
bool operator<=(const tuple<T1, T2, ..., TN>&, const tuple<U1, U2, ..., UN>&);

template<class T1, class T2, ..., class TN, class U1, class U2, ..., class UN>
bool operator>=(const tuple<T1, T2, ..., TN>&, const tuple<U1, U2, ..., UN>&);
\end{verbatim}
\end{minipage}

\medskip


\req{Requires:} \code{tuple\_size<tuple<T1, T2, ..., TM> >::value == tuple\_size<tuple<U1, U2, ..., UM> >::value == N}. 
For all \code{i}, where \code{0 <= i < N},
\code{get<i>(t) \code{$\odot$} get<i>(u)} is a valid expression returning a type that is
convertible to \code{bool}, where \code{$\odot$} is either \code{<=} or \code{>=}.\\
\req{Returns:} The result of a lexicographical comparison with \code{$\odot$} between \code{t} and \code{u}, defined equivalently to:

\code{(bool)(get<0>(t) $\odot$ get<0>(u)) \&\& (!((bool)(get<0>(u) $\odot$ get<0>(t)) ||
                       t$_{\mathrm{tail}}$ $\odot$ u$_{\mathrm{tail}}$)}, \\
where \code{r$_{\mathrm{tail}}$}
        for some tuple \code{r} is a tuple containing all but the first element of \code{r}. 
For any two zero-length tuples \code{e} and \code{f}, \code{e $\odot$ f} returns \code{true}.

\medskip

\noindent
\req{Notes:} The above definitions for comparison operators 
do not impose the requirement that 
\code{t$_{\mathrm{tail}}$} (or \code{u$_{\mathrm{tail}}$}) must be 
constructed. It may be even impossible, as \code{t} (or \code{u}) is 
not required to be copy constructible.
Also, all comparison operators are short circuited to not perform element
accesses beyond what is required to determine the result of the comparison.


\subsubsection*{Input and output}


\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class CharType, class CharTrait, class T1, class T2, ..., class TN>
basic_ostream<CharType, CharTrait>& 
operator<<(basic_ostream<CharType, CharTrait>& os, 
           const tuple<T1, T2, ..., TN>& t);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} For all $i$ = 0, 1, ..., N-1 in \verb|os << get<i>(t)|
is a valid expression.\\
\req{Effects:} Inserts \code{t} into \code{os} as \code{$L$t$_0$$d$t$_1$$d$...$d$t$_nR$}, where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple formatting manipulators.
Each element \code{t$_i$} is output by invoking \verb|os << get<i>(t)|.
A zero-element tuple is output as $LR$ and a one-element tuple is output as \code{$L$t$_0R$}.
\\
\req{Returns:} \code{os}

\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class CharType, class CharTrait, class T1, class T2, ..., class TN>
basic_istream<CharType, CharTrait>& 
operator>>(basic_istream<CharType, CharTrait>& is, 
           tuple<T1, T2, ..., TN>& t);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} For all $i$ = 0, 1, ..., N-1 in \verb|is >> get<i>(t)|
is a valid expression.\\
\req{Effects:} Extracts a tuple of the form \code{$L$t$_0$$d$t$_1$$d$...$d$t$_nR$},
where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple formatting manipulators.
Each element \code{t$_i$} is extracted by invoking \verb|is >> get<i>(t)|.
A zero-element tuple expects to extract $LR$ from the stream and 
one-element tuple expects to extract \code{$L$t$_0R$}.
If bad input is encountered, calls \code{is.set\_state(ios::failbit)} (which
may throw \code{ios::failure} (27.4.4.3)).\\
\req{Returns:} \code{is}\\
\req{Notes:} It is not guaranteed that a tuple written to 
a stream can be extracted back to a tuple of the same type.

\subsubsection*{Tuple formatting manipulators}

The library defines the following three stream manipulator functions.
The types designated \emph{tuple\_manip1}, \emph{tuple\_manip2} and \emph{tuple\_manip3} are implementation-specified.

\medskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{alltt}
\textrm{\emph{tuple_manip1}} tuple_open(char_type c);
\textrm{\emph{tuple_manip2}} tuple_close(char_type c);
\textrm{\emph{tuple_manip3}} tuple_delimiter(char_type c);
\end{alltt}
\end{minipage}

\medskip 

\req{Returns:} Each of these functions returns an object \code{s} of unspecified 
type such that if \code{out} is an 
instance of \code{basic\_ostream<charT,traits>}, \code{in} is an instance of
\code{basic\_istream<charT,traits>} and \code{char\_type} equals \code{charT},
then the expression \verb|out << s| (respectively \verb|in >> s|) 
sets \code{c} to be
the opening, closing, or delimiter character (depending on the manipulator
function called) to be used when writing tuples into \code{out} (respectively
extracting tuples from \code{in}).\\
\req{Notes:} Implementations are not required to support these manipulators for 
streams with \code{sizeof(charT) > sizeof(long)}; \verb|out << s| and \verb|in >> s| are required to fail at compile time if 
\code{out} and \code{in} are such streams and the implementation does not
support tuple formatting manipulators for them.

\medskip 

\noindent \textsf{[The constraint stated in the above \textbf{Notes} section allows an 
implementation where the delimiter characters are stored in
space allocated by \code{xalloc}, which allocates an array of \code{long}s.
A more general alternative is to store pointers to the delimiter 
characters in the \code{xalloc}-allocated array, and register a callback 
function (with \code{ios\_base::register\_callback}) for the stream to 
take care of deallocating the memory.
If this approach is taken, the delimiters could be chosen to be strings 
instead of single characters.
This might be worthwhile, such as to allow delimiters like \code{", "}.
]}


\section{Utility components}

The library provides the class template \code{reference\_wrapper} that 
stores a reference to an object in a CopyConstructible wrapper, and two 
\code{reference\_wrapper} construction functions that allow the user to 
express the intent in storing a reference instead of a copy.

\medskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{alltt}
template<typename T>
class reference_wrapper \{
public:
  typedef T type;
   
  explicit reference_wrapper(T &);

  operator T& () const;
  T& get() const;
\};
\end{alltt}
\end{minipage}

\medskip 

\noindent\hspace{\parindent}  
\verb|explicit reference_wrapper(T& t));|

\medskip 

\req{Postconditions:} \verb|this->get()| is equivalent to \code{t}.\\
\req{Throws:} will not throw.

\bigskip

\noindent\hspace{\parindent}  
\verb|operator T& () const;|

\medskip 

\req{Returns:} \verb|this->get()|\\
\req{Throws:} will not throw.

\bigskip 

\noindent\hspace{\parindent}  
\verb|T& get() const;|

\medskip

\req{Returns:} the stored reference.\\
\req{Throws:} will not throw.

\bigskip 

\noindent\hspace{\parindent}  
\verb|template<typename T> reference_wrapper<T> ref(T& t);|

\medskip 

\req{Returns:} \verb|reference_wrapper<T>(t)|\\
\req{Throws:} will not throw.

\bigskip 

\noindent\hspace{\parindent}  
\verb|template<typename T> reference_wrapper<T const> cref(const T& t);|

\medskip 

\req{Returns:} \verb|reference_wrapper<T const>(t)|\\
\req{Throws:} will not throw.

\bigskip 

\noindent The library provides the class \code{swallow\_assign}:
%

\medskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
struct swallow_assign {
  template <class T> 
  swallow_assign& operator=(const T&) { return *this; }
};
\end{verbatim}
\end{minipage}

\bigskip 

\noindent The library provides an object
\code{ignore} of type \code{swallow\_assign}.

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
extern swallow_assign ignore;
\end{verbatim}
\end{minipage}


\section{Pairs}

\textsf{[Additions to pair to work with tuples]}

\medskip 


\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2>
struct tuple_size<pair<T1, T2> > {
  static const int value = 2;
};
\end{verbatim}
\end{minipage}

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2>
struct tuple_element<0, pair<T1, T2> > {
  typedef T1 type;
};

template<class T1, class T2>
struct tuple_element<1, pair<T1, T2> > {
  typedef T2 type;
};
\end{verbatim}
\end{minipage}

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<int I, class T1, class T2>
P& get(pair<T1, T2>&);

template<int I, class T1, class T2>
const P& get(const pair<T1, T2>&);
\end{verbatim}
\end{minipage}

\medskip 

\req{Return type:} 
If \code{I} is \code{0} then \code{P} is \code{T1}, 
if \code{I} is \code{1} then \code{P} is \code{T2},
otherwise the program is ill-formed.\\
\req{Returns:} If \code{I == 0} returns \code{p.first}, otherwise
returns \code{p.second}.

\bigskip


\section{Acknowledgements}

The author is indebted to Jeremiah Willcock, Douglas Gregor and Gary Powell,
as well as to Jeremy Siek and Dave Abrahams for their invaluable help 
in preparing this document.
%
The Boost Tuple Library, the basis of this proposal, has benefited from 
suggestions by many in the Boost community, including 
Jens Maurer, William Kempf,
 Vesa Karvonen, John Max Skaller,
Ed Brey, Beman Dawes, and Hartmut Kaiser.


\bibliography{tuple_proposal}
\bibliographystyle{plain}


\end{document}


