=====================================================
Rationale for the partial function application syntax
=====================================================

Terminology:

The function, or function object, that is being applied partially 
is referred to as target function.

There are basically two syntaces for partial function application.

1. Partial application is a single function call, where the target function
   is the first argument. For example:
 
   bind(f, _1, b, _2)

2. The first function call makes the target function partially applicable,
   and the (partial) argument list is given with a separate function call.
   For example:

   lazy(f)(_1, b, _2)

There are pros and cons on both approaches. In the following list, 
bind refers to the 1st approach above, lazy to the 2nd approach.

Clarity of the syntax:
----------------------

If the target function is a normal function or function object, lazy has 
a clearer syntax. The argument list of the function is a distinct entity.

On the other hand, with pointers to member functions, the syntactic benefit
of lazy is less obvious. For example:

class A {
public: 
  void foo(int i); 
  ...
}

int x;

bind(&A::foo, _1, x);

// vs.

lazy(&A::foo)(_1, x);


Neither maps directly to the ideal syntax: _1.foo(x)


Ease of implementation:
-----------------------

No real difference. In lazy only one definition of lazy is needed, whereas
an overload of bind is needed for each different number of arguments.
However, the function object class resulting from lazy must overload 
the function call operator for each different number of arguments.
Also, both versions require N overloads within the template that 
represents the partially applied function, where N is the number of 
supproted placeholders. Furthermore, when the target functions are 
actually called, in both approaches overloads are needed for each 
different numbers of arguments of the target function.

Note that a defect report about function templates and 
default arguments has been resolved; template functions can have 
default arguments, which can reduce the number of overloads on both 
cases [Jaakko's comment: is this true?]


Safety:
-------

lazy can be a source of hard-to-find errors. Consider the following example:

  for_each(a.begin(), a.end(), bind(f, x, _1));

  for_each(a.begin(), a.end(), lazy(f)(x, _1));

Now consider this:

  for_each(a.begin(), a.end(), lazy(f)); // oops, forgot the argument list

This code compiles, but does not do anything.

There does not seem to be an easy way to make the compiler notice this
kind of error. It is not impossible, though. If F is a result of a call 
to lazy. then the function call operators in F can be defined only for 
the cases where at least one of the arguments is a placeholder, 
or another lazy function. Note, that this would prevent the same syntax to be 
used when all arguments are bound.

For example:
  void foo(A, B, C); A a; B b; C c;
  lazy(f)(a, b, c) // this would not work
  lazy(f)(var(a), b, c) // something like this would work but it is not pretty

Existing practice:
------------------

Both approaches are being used in existing libraries, lazy in Phoenix (part of 
the Spirit parser library), and bind in Boost.Bind and Boost.Lambda.
The bind apporach is, however, more widely known and is existing practice. 

Design decision:
----------------

Weighing the options above, the conclusion was to emphasize safety over 
syntactic clarity, particularly as it is questionable, whether one 
approach is syntactically any better than the other in all cases.
Hence, we abandon the lazy syntax and choose bind. 

