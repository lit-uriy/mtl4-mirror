// vim: syn=cpp:
#ifndef STD_TUPLE_TUPLE
#define STD_TUPLE_TUPLE

#define STD_TUPLE_NS std_tuple

namespace STD_TUPLE_NS { // To allow for change for std later
  // tag for tuples
  namespace detail {
    struct tuple_tag {};
  }

  // is_tuple and is_tuple_like
  template <class T>
  struct is_tuple {
    BOOST_STATIC_CONSTANT(bool, value = boost::is_base_and_derived<detail::tuple_tag, T>::value);
  };

  template <class T>
  struct is_tuple_like: public is_tuple<T> {};

  // Tuple size
  template <class T>
  struct tuple_size {
    BOOST_STATIC_CONSTANT(int, value = 1);
  };

  // ct_if
  namespace detail {
    template <bool B, class T, class E>
    struct ct_if {typedef T type;};

    template <class T, class E>
    struct ct_if<false,T,E> {typedef E type;};
  }

  // Get element type and value
  template <int N, class T> struct tuple_element_tuple;
  template <int N, class T> struct tuple_element_nontuple;

  template <int N, class T>
  struct tuple_element
    : public typename detail::ct_if<is_tuple<T>::value,
				    tuple_element_tuple<N,T>,
				    tuple_element_nontuple<N,T> >::type {};

  template <int N, class T>
  struct tuple_element_nontuple {};

  template <class T>
  struct tuple_element_nontuple<0,T> {
    typedef T type;
    static T& get(T& x) {return x;}
    static const T& const_get(const T& x) {return x;}
  };

  template <int N, class T>
  struct tuple_element_tuple { /* empty */ };
  // This class must be specialized for standard tuple types

  template <int N, class T>
  typename enable_if<!is_tuple<T>::value, tuple_element<N,T> >::type::type
  get(T& x) {
    return tuple_element<N,T>::get(x);
  }

  template <int N, class T>
  const typename enable_if<!is_tuple<T>::value, tuple_element<N,T> >::type::type
  get(const T& x) {
    return tuple_element<N,T>::const_get(x);
  }








  // Tuple functions
  template <int Start, int Length, class T1, class T2>
  struct tuple_short_circuit {
    const T1& t1; const T2& t2;
    tuple_short_circuit(const T1& t1_, const T2& t2_): t1(t1_), t2(t2_) {}
    typedef tuple_short_circuit<Start+1, Length, T1, T2> next;
    bool eq() const {return get<Start>(t1) == get<Start>(t2) &&
			    next(t1,t2).eq();}
    bool ne() const {return get<Start>(t1) != get<Start>(t2) ||
			    next(t1,t2).ne();}
    bool lt() const {
      if (get<Start>(t1) < get<Start>(t2)) return true;
      if (get<Start>(t2) < get<Start>(t1)) return false;
      return next(t1,t2).lt();
    }
    bool gt() const {
      if (get<Start>(t1) > get<Start>(t2)) return true;
      if (get<Start>(t2) > get<Start>(t1)) return false;
      return next(t1,t2).gt();
    }
    bool le() const {
      if (!(bool)(get<Start>(t1) <= get<Start>(t2))) return false;
      if (!(bool)(get<Start>(t2) <= get<Start>(t1))) return true;
      return next(t1,t2).le();
    }
    bool ge() const {
      if (!(bool)(get<Start>(t1) >= get<Start>(t2))) return false;
      if (!(bool)(get<Start>(t2) >= get<Start>(t1))) return true;
      return next(t1,t2).ge();
    }
  };

  template <int Start, class T1, class T2>
  struct tuple_short_circuit<Start,Start,T1,T2> {
    tuple_short_circuit(const T1&, const T2&) {}
    bool eq() const {return true;}
    bool ne() const {return false;}
    bool lt() const {return false;}
    bool gt() const {return false;}
    bool le() const {return true;}
    bool ge() const {return true;}
  };

  template <class T1, class T2>
  typename detail::enable_if<tuple_size<T1>::value == tuple_size<T2>::value,
			     bool>::type
  tuple_eq(const T1& t1, const T2& t2) {
    return detail::tuple_short_circuit<0,tuple_size<T1>::value,T1,T2>(t1,t2).eq();
  }

  template <class T1, class T2>
  typename detail::enable_if<tuple_size<T1>::value == tuple_size<T2>::value,
			     bool>::type
  tuple_ne(const T1& t1, const T2& t2) {
    return detail::tuple_short_circuit<0,tuple_size<T1>::value,T1,T2>(t1,t2).ne();
  }

  template <class T1, class T2>
  typename detail::enable_if<tuple_size<T1>::value == tuple_size<T2>::value,
			     bool>::type
  tuple_lt(const T1& t1, const T2& t2) {
    return detail::tuple_short_circuit<0,tuple_size<T1>::value,T1,T2>(t1,t2).lt();
  }

  template <class T1, class T2>
  typename detail::enable_if<tuple_size<T1>::value == tuple_size<T2>::value,
			     bool>::type
  tuple_gt(const T1& t1, const T2& t2) {
    return detail::tuple_short_circuit<0,tuple_size<T1>::value,T1,T2>(t1,t2).gt();
  }

  template <class T1, class T2>
  typename detail::enable_if<tuple_size<T1>::value == tuple_size<T2>::value,
			     bool>::type
  tuple_le(const T1& t1, const T2& t2) {
    return detail::tuple_short_circuit<0,tuple_size<T1>::value,T1,T2>(t1,t2).le();
  }

  template <class T1, class T2>
  typename detail::enable_if<tuple_size<T1>::value == tuple_size<T2>::value,
			     bool>::type
  tuple_ge(const T1& t1, const T2& t2) {
    return detail::tuple_short_circuit<0,tuple_size<T1>::value,T1,T2>(t1,t2).ge();
  }

  template <class T1, class T2>
  typename detail::enable_if<is_tuple<T1>::value && is_tuple<T2>::value,
			     bool>::type
  operator ==(const T1& t1, const T2& t2) {
    return tuple_eq(t1,t2);
  }

  template <class T1, class T2>
  typename detail::enable_if<is_tuple<T1>::value && is_tuple<T2>::value,
			     bool>::type
  operator !=(const T1& t1, const T2& t2) {
    return tuple_ne(t1,t2);
  }

  template <class T1, class T2>
  typename detail::enable_if<is_tuple<T1>::value && is_tuple<T2>::value,
			     bool>::type
  operator <(const T1& t1, const T2& t2) {
    return tuple_lt(t1,t2);
  }

  template <class T1, class T2>
  typename detail::enable_if<is_tuple<T1>::value && is_tuple<T2>::value,
			     bool>::type
  operator >(const T1& t1, const T2& t2) {
    return tuple_gt(t1,t2);
  }

  template <class T1, class T2>
  typename detail::enable_if<is_tuple<T1>::value && is_tuple<T2>::value,
			     bool>::type
  operator <=(const T1& t1, const T2& t2) {
    return tuple_le(t1,t2);
  }

  template <class T1, class T2>
  typename detail::enable_if<is_tuple<T1>::value && is_tuple<T2>::value,
			     bool>::type
  operator >=(const T1& t1, const T2& t2) {
    return tuple_ge(t1,t2);
  }


  // Actual tuple types
  namespace detail {
    struct tuple0: public tuple_tag {};
  }

  template <>
  struct tuple_size<detail::tuple0> {
    BOOST_STATIC_CONSTANT(int, value = 1);
  };

  namespace detail {
    struct tuple1_tag {};

    template <class T> struct tuple1_nesting_depth;

    template <bool B, class T>
    struct tuple1_nesting_depth_helper {
      BOOST_STATIC_CONSTANT(int, value = 0);
    };

    template <class T>
    struct tuple1_nesting_depth_helper<true, T> {
      BOOST_STATIC_CONSTANT(int, 
	(value =
	  1 + tuple1_nesting_depth<typename tuple_element<T>::type>::value));
    };

    template <class T>
    struct tuple1_nesting_depth: public
      tuple1_nesting_depth_helper<
	boost::is_base_and_derived<tuple1_tag,T>::value,
	T> {}

    template <class T>
    class tuple1: public tuple1_tag, public tuple_tag {
      public:
      T value;

      // public:
      tuple1(): value() {}
      tuple1(const tuple1& o): value(o.value) {}

      // Construct from member
      template <class U>
      tuple1(const U& v, typename enable_if<
	  tuple1_nesting_depth<U>::value <= tuple1_nesting_depth<T>::value,
	  bool>::type = false): value(v) {}

      template <class U>
      tuple1(const U& v, int): value(v) {}
      
      // Construct from other 1-tuple
      template <class U>
      tuple1(const U& v, typename enable_if<
	  tuple1_nesting_depth<U>::value > tuple1_nesting_depth<T>::value,
	  bool>::type = false): value(get<0>(v)) {}
    };
  }

  template <class T>
  struct tuple_element_tuple<0, detail::tuple1<T> > {
    typedef T type;
    static typename boost::add_reference<T>::type
    get(detail::tuple1<T>& x) {return x.value;}

    static typename boost::add_reference<const T>::type
    const_get(const detail::tuple1<T>& x) {return x.value;}
  };
}


#endif
