\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

%\usepackage[finnish]{babel}

\newcommand{\effects}{\noindent \textbf{Effects:}}
\newcommand{\returns}{\noindent \textbf{Returns:}}
\newcommand{\returntype}{\noindent \textbf{Return type:}}
\newcommand{\requires}{\noindent \textbf{Requires:}}
\newcommand{\notes}{\noindent \textbf{Notes:}}
\newcommand{\values}{\noindent \textbf{Value:}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\concept}[1]{\textsf{#1}}

\author{Jaakko Järvi}

\title{Proposal for adding tuple types into the standard library\\N1382=02-0040}


\begin{document}
\maketitle{}

\section{Motivation}

This proposal describes tuple types for C++.
Everything proposed here can be implemented as a library, but the proposal
intentionally leaves room for tuples as a built in type.
We do not propose a fixed implementation, as there are several alternatives
for implementing tuples. Also, new language features, such as variable
length template argument lists may make currently unimplementable approaches
possible.

Tuple template is basically a generalization of the \code{pair} template 
from two to arbitrary (up to a predefined limit) number of elements.
Compared to pairs, the proposed tuple template supports a wider range 
of element types (e.g. references) and streaming operations, customizable
with specific manipulators.
Further, the library provides \code{tie} functions for creating tuples 
with reference elements. 
These make tuples convenient as return types of functions.


Tuple types are a general utility for the end user, to be used similarly 
to pairs. 
Also, tuples are an important tool for library implementers for representing
a set of template arguments, a set of function arguments, etc. as a single
entity.
\textbf{JAAKKO: esimerkkiejä}.

\section{Impact on the standard}

The proposed library does not require any core language changes.
We propose tuple definitions to be included by including the \code{<utility>} 
header, which is where \code{pair} resides in.
However, operators for reading tuples from a stream and writing tuples into
a stream do introduce a dependency to \code{<istream>} and \code{<ostream>}.
\textbf{JAAKKO: should istream and ostream include utility, should there
be tupleio header ??=}.

Note that tuples would benefit from a set of core language changes:
\begin{itemize}
\item Variable length template argument lists.
\item Making reference to a reference to some type \code{T} equal to 
reference to \code{T}.
\item Allowing default arguments (both template and function) for function
templates.
\end{itemize}

\section{Tuples in a nutshell}

\subsection{Defining tuple types}

The \code{tuple} template can be instantiated with any number of arguments
between 0 and 10 elements. 
The argument types can be any valid C++ types.
Examples:
\begin{verbatim}
typedef tuple<A, const B, volatile C, const volatile D> t1;
typedef tuple<int, int&, const int&, const volatile int&> t2;
typedef tuple<void, int()(int)> t3;
\end{verbatim}

\subsection{Constructing tuples}

A $n$ element tuple has a default constructor, 
converting copy constructor, 
and a constructor with $n$ parameters.
The types of the elements restrict which constructors can be used:
\begin{itemize}
\item If an $n$-element tuple is constructed with a constructor taking 
0 elements, all elements must be default constructible.

\item If an $n$-element tuple is constructed with a constructor taking 
$n$ elements, all elements must be copy constructible and implicitly 
convertible from the corresponding argument.
For example
\begin{verbatim}
tuple<int, const int, std::string>(1, 'a', "Hi")
\end{verbatim}

\item If an $n$-element tuple is constructed with the converting copy 
constructor, the argument type must be a model of the \concept{Tuple} concept
and the each element must be elementwise copy constructible.
\end{itemize}

\begin{verbatim}
tuple<int, float, std::string> t1;
t1 = tuple<char, int, char[]>('a', 1, "Hi");
\end{verbatim}


\subsection{Assignment}

The assignment operation is defined from any object that models
the \concept{Tuple} concept and where the element types are elementwise 
assignable.

\subsection{Number of elements, element types}

Tuples make the number of element accessible as a compile time constant 
\code{size}.
\begin{verbatim}
tuple<int, int, int, int>::size; // equals 4
\end{verbatim}

The type of the \code{N}th element can be accessed as a typedef within
a nested template \code{element}:
\begin{verbatim}
tuple<int, char, float, double>::element <2>::type // float
\end{verbatim}
Indexing is zero based. Index out of bounds results in a compilation error.

\subsection{Element access}

Let \code{t} be a tuple object. 
The expression t[index<N>] returns the reference to the \code{N}th element
of \code{t}, where \code{N} is an integral constant expression.
\begin{verbatim}
tuple<int, float, char>(1, 3.14, 'a') t;
t.[index<2>] // equals 'a'
\end{verbatim}
Indexing is zero based. Index out of bounds results in a compilation error.

\subsection{Relational operators}

A relational operator \emph{op} is defined between two tuples \code{T} 
and \code{U}, iff \code{T} and \code{U} have the same number of elements,
and for all element positions, \emph{op} is defined between the element 
from \code{T} and the element from \code{U}.
\begin{verbatim}
tuple<int, float, char> t; 
tuple<int, char, int> u;
t < u; // is defined

tuple<int, int, int, int> x;
tuple<int, int, int> y; 
x < y; // not defined, different size

tuple<int, int, complex<double>, int> x;
tuple<int, int, std::string, int> y; 
x < y; // not defined, no operator< between complex<double> and std::string
\end{verbatim}

The operators \code{<}, \code{>}, \code{<=}, \code{>=} each define a 
lexicographical ordering. (JAAKKO: stick somewhere justification, std::pair,
Haskell)
The \code{operator==} is defined as the logical and of the elemenwise 
equality comparisons.
The \code{operator!=} is defined as the logical or of the
elementwise comparisons.

Each comparison operator \emph{op} is defined solely using the same
operator \emph{op} for the elementwise comparisons and makes no assumptions
about the behaviour respect to the other relational operators, or even
to whether they are defined or not.

\subsection{Input and output}

A tuple type is \concept{OutputStreamable} (JAAKKO: explain these concepts)
if each of its elements are 
\code{OutputStreamable}.
A tuple is \concept{InputStreamable} if each of its elements are 
\concept{InputStreamable}.
Note however, that in general it is not guaranteed, that a tuple written to 
an ostream can be read back from an istream to a tuple that can be
written to an ostream , and if the delimiters that are used between
the two 

Tuple objects can be written to an ostream with \code{operator<<} if
each element is 
read from an istream with \code{operator>>}.


We describe an implementation that conforms to the requirements
of this proposal.

\section{Text in the standard}

\section{Tuple Library}

The library provides a tuple type as 
the class template \code{tuple} that can be instantiated with any number
of arguments.
The implementation can set an upper limit for the number of arguments.
Each template argument specifies the type of an element in the \code{tuple}.
Consequently, tuples are heterogeneous fixed size collections.
of values. 

Implementation quantites:

- Number of elements in one tuple type [10].

Implementations are allowed to define the tuple template as an interface,
which inherits from some templated base class \code{T}.
If \code{T} provides all the functionality provided , and overload tuple operations (converting copy
constructors, assignments, conversion operators, etc.) for the \code{T}
templates, instead of \code{tuple} templates.

 The notation \code{T1, T2, ..., Tn} 
stands for a comma separated list of
types which may contain any number of elements from 0 to \code{n} 
(where \code{n} <= maximum number of allowed tuple elements), 
and \code{t1, t2, ..., tn} respectively for a set of objects. 

The following subclauses describe the requirements for the tuple
type.


\paragraph{Notation}

\begin{tabular}{ll}
\code{T}, \code{U} & are tuple types\\
\code{t}, \code{u} & objects of types \code{T} and \code{U}\\
\code{tc}, \code{uc} & objects of types \code{const T} and \code{const B}\\
\code{T}$_i$ & LISÄÄTÄHÄN 
\end{tabular}

\paragraph{Participating types}

\paragraph{Valid Expressions}
\begin{itemize}

\item Number of elements

\code{T::size} \\
\code{tuple\_traits<T>::size}\\
\returntype\ \code{const int} (integral constant expression).\\
\values\ Number of elements in \code{T}.\\

\item Element type

\code{T::element<N>::type}\\
\code{tuple\_traits<T>::element<N>::type}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\ 
\values\ The type of the \code{N}th element type of tuple type \code{T}.\\

\item Element access

\code{get<N>(t)}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\
\returntype\ \code{T::element<N>::type\&}.\\
\returns\ The \code{N}th element of \code{t}.\\

\code{get<N>(tc)}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\
\returntype\ \code{const T::element<N>::type\&}.\\
\returns\ The \code{N}th element of \code{t}.\\

\item Assignment

\code{t = u}\\
\requires\ \code{T::size == U::size}. For all $i$, \\
\code{t$_i$ = u$_i$} is a valid expression.\\
\effects\ Performs \code{t$_i$ = u$_i$} for all $i$.\\
\returntype\ \code{T&}.\\
\returns\ \code{t}.

\item Equality comparison

\code{t == u}\\
\requires\ \code{T::size == U::size}. For all $i$, \\
\code{t$_i$ == u$_i$} is a valid expression.\\
\returntype\ \code{bool}.\\
\returns\ \code{true} iff {t$_i$ == u$_i$} for all  $i$


\code{
\end{itemize}



\subsection{Construction}

\begin{verbatim}
tuple<T0, T1, ..., TN>()
\end{verbatim}
\requires\ Each element type must be \concept{DefaultConstructible}.
\effects\ Default initializes each element.

\begin{verbatim}
tuple<T0, T1, ... TN>(t0, t1, ..., tN)
\end{verbatim}
\requires\ Each element type \code{Ti} type is
\concept{CopyConstructible}. JAAKKO: Are all requirements of CopyConstructible
required.
Each \code{ti} is convertible to \code{Ti}.
\effects\ Copy initializes each element with the value of the corresponding 
parameter.

\begin{verbatim}
tuple<T0, T1, ... TN>(u); 
\end{verbatim}
\requires\ 



\end{document}

- Onko non-storeable trikki tarpeellinen

- Miksi assignment riittää paireista tupliin
- Mikä on tuple_size:n return type


The tuple type is impelemented as an interface template \code{tuple} that
can take up to $n$ (10 in the reference implementation) template arguments.
It is very tedious to overload functions for such a verbose type.
Consequently, the \code{tuple} interface class inherits from instantiations
of another type (\code{cons}) which represents the tuple element as a 
\emph{cons list}.
Comparison operators, streaming operators and element accessor functions all 
operate on the cons list representation.

We propose this representation be standardized as well, to give end programmers
a convenient way to overload functions for tuple types. 



The library provides traits classes for querying 
properties of tuples and their elements:

\begin{verbatim}
tuple_size<T>::value
\end{verbatim}
\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}. \\
\values\ \code{const int} holding the number of elements in the cons list \code{T}.

\begin{verbatim}
tuple_element<N, T>::type
\end{verbatim}
\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}. \\
$0 \leq $ \code{N} $ < $ \code{tuple\_size<T>::value}.
\values\ The type of the \code{N}th element in \code{T}.

\begin{verbatim}
template <int N, class H, class T> rt? get(cons<H, T>&);
template <int N, class H, class T> rt? get(const cons<H, T>&);
\end{verbatim}

\begin{verbatim}
inline bool operator==(const null_type&, const null_type&);
inline bool operator>=(const null_type&, const null_type&);
inline bool operator<=(const null_type&, const null_type&);
\end{verbatim}
\returns\ \code{true}.

\begin{verbatim}
inline bool operator!=(const null_type&, const null_type&);
inline bool operator<(const null_type&, const null_type&);
inline bool operator>(const null_type&, const null_type&);
\end{verbatim}
\returns\ \code{false}.

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator==(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}
\returns\ \code{true} if all elementwise comparisons are true.
\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator!=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator<(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator>(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator<=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator>=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}





\noindent \textbf{Header} \verb|<tuple>| synopsis

\begin{verbatim}

template<class T> int tuple_size(const T&);
int tuple_size(null_type);

template <int N, class T> class tuple_element;
template <int N, class H, class T> rt? get(cons<H, T>&);
template <int N, class H, class T> rt? get(const cons<H, T>&);

template <class H1, class T1, class H2, class T2>
inline bool operator==(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator!=(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator<(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator>(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator<=(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator>=(const cons<H1, T1>& a, const cons<H2, T2>& b);

\end{verbatim}


The type of the heterogeneous list type is:

\begin{verbatim}
class null_type {};

template <class H, class T>
class cons {
  H head_;
  T tail_;
public:
  typedef H head_type;
  typedef T tail_type;

  head_type& head();
  const head_type& head() const;

  tail_type& tail();
  const tail_type& tail() const;

  cons();
  cons(const typename remove_volatile<head_type>::type& h,
       const tail_type& t);

  template <class H2, class T2>
  cons( const cons<H2, T2>& u ) : head(u.head), tail(u.tail) {}

  template <class HT2, class TT2>
  cons& operator=( const cons<HT2, TT2>& u );

  cons& operator=(const cons& u);

  template <class T1, class T2>
  cons& operator=( const std::pair<T1, T2>& u );
}
\end{verbatim}

\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}.

\begin{verbatim}
cons();
\end{verbatim}
\effects\ Default initializes \code{head\_} and \code{tail\_}.

\begin{verbatim}
cons(const typename remove_volatile<head_type>::type& h, 
     const tail_type& t);
\end{verbatim}
\requires{All elements are \concept{CopyConstructible}}.
\effects\ Initializes \code{head\_} with \code{h}
and \code{tail\_} with \code{t}.\\
\notes\ 
Unless \code{head\_type} is a non-const reference type, it is allowed 
to call the constructor with a temporary as the first argument.
When binding temporaries to references, the reference must
be to a non-volatile and const type (8.5.3 (5)). Thus \code{volatile}
is removed and \code{const} added. Reference types stay intact.


\begin{verbatim}
template <class H2, class T2> cons(const cons<H2, T2>& u);
\end{verbatim}

\effects\ Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.


\begin{verbatim}
template <class HT2, class TT2> cons& operator=(const cons<HT2, TT2>& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}


\begin{verbatim}
cons& operator=(const cons& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}\\
\notes\ Default assignment operator is illformed if a class contains
member variables of reference types (12.8 (12)). 
Therefore an explicit definition is needed.

\begin{verbatim}
template <class T1, class T2> cons& operator=(const std::pair<T1, T2>& u);
\end{verbatim}
\requires\ \code{tuple\_size<cons> == 2} (ref????).\\
\effects\ As if implemented: 
\code{*this.head\_ = u.first; *this.tail\_.head\_ = u.second;}\\
\returns\ \code{*this}

\begin{verbatim}
head_type& get_head();
\end{verbatim}
\returns\ Reference to \code{head\_}. 

\begin{verbatim}
const head_type& get_head() const;
\end{verbatim}
\returns\ Reference to \code{head\_}.\\
\notes\ Constness is shallow. If \code{head\_type} is a non-const reference 
type, returns a non-const reference.

\begin{verbatim}
tail_type& get_tail();
const tail_type& get_tail() const;
\end{verbatim}
\returns\ Reference to tail. %NIL CASE ???

%template <class T1, class T2, ... class T10>
%class tuple {
%public:



\subsection{Tuples}



\concept{ConsList} requirements:

ConsLists are heterogeneous containers. 
They allow the access to
the \emph{head} (first element) and \emph{tail} (a ConsList consisting
of all but the head), as well as to the $n$th element, where $n$ is 
known at compile time.

\paragaph{Notation}
\tabular{ll}
\code{T} & is a type that is a model of \concept{ConsList}
\code{t} & object of type \code{T}
\code{U} & is a type that is a model of \concept{ConsList}
\code{u} & object of type \code{U}

\paragraph{Participating types}

\paragraph{Valid Expressions}
\begin{itemize}

\item Number of elements

\code{T::length} 

\returntype\ \code{static const int}.\\
%\semantics\ Number of elements in \code{T}.\\

& integral constant, number of elements in \code{T} \\

\end{itemize}




\begin{tabular}{lll}

\code{T} and \code{U} are types to be supplied by a C++ program 
intantiating a template, \code{t} is a value of type \code{T}, 
\code{u} a value of type \code{U}, \code{tc} and \code{uc} are 
value of types \code{const T} and \code{const U} respectively.





\concept{NonEmptyConsList} requirements:

The \concept{ConsList} 

\code{T} and \code{U} are types to be supplied by a C++ program 
intantiating a template, \code{t} is a value of type \code{T}, 
\code{u} a value of type \code{U}, \code{tc} and \code{uc} are 
value of types \code{const T} and \code{const U} respectively.

\begin{tabular}{lll}

\textbf{expression} & \textbf{return type} & \textbf{requirement} \\

\code{T::head\_type} & the type of the first element in \code{T} \\

\code{T::tail\_type} & a type \code{TT} that is a model of \concept{ConsList} 
and ... \\

\code{t.head()} & \code{T::head\_type\&} \\

\code{t.head() const} & \code{const T::head\_type\&} & \\

\code{a.tail()} & \code{T::tail\_type\&} \\

\code{a.tail() const} & \code{const T::tail\_type\&} & \\

\code{T::length} & integral constant, number of elements in \code{T} \\

\code{T(u)} & & \code{u} is equivalent to \code{T(u)}\\

\end{tabular}




\begin{verbatim}
  template <class T0, class T1, ... class TN>

  class tuple {

    typedef T0 head_type;
    typedef tail_type;  

    tuple() : base() {}
  
    // tuple_traits_parameter<T>::type takes non-reference types as const T& 
    explicit 
    tuple(typename tuple_detail::parameter<T0>::type t0,
	  typename tuple_detail::parameter<T1>::type t1 
	    = tuple_detail::def_value<T1>::f(),
	  typename tuple_detail::parameter<T2>::type t2 
	    = tuple_detail::def_value<T2>::f(),
	  typename tuple_detail::parameter<T3>::type t3 
	    = tuple_detail::def_value<T3>::f(),
	  typename tuple_detail::parameter<T4>::type t4 
	    = tuple_detail::def_value<T4>::f(),
	  typename tuple_detail::parameter<T5>::type t5 
	    = tuple_detail::def_value<T5>::f(),
	  typename tuple_detail::parameter<T6>::type t6 
	    = tuple_detail::def_value<T6>::f(),
	  typename tuple_detail::parameter<T7>::type t7 
	    = tuple_detail::def_value<T7>::f(),
	  typename tuple_detail::parameter<T8>::type t8 
	    = tuple_detail::def_value<T8>::f(),
	  typename tuple_detail::parameter<T9>::type t9 
	    = tuple_detail::def_value<T9>::f())
      : base(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}
    
    template<class U1, class U2>
    tuple(const cons<U1, U2>& p) : base(p) {}

    template <class U1, class U2>
    tuple& operator=(const cons<U1, U2>& k) { 
      base::operator=(k); 
      return *this;
    }

    template <class U1, class U2>
    tuple& operator=(const std::pair<U1, U2>& k) { 
      BOOST_STATIC_ASSERT(tuple_size<tuple>::value == 2);// check_size = 2
      this->head = k.first;
      this->tail.head = k.second; 
      return *this;
    }
    
  };
\end{verbatim}

