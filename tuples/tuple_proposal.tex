\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

%\usepackage[finnish]{babel}

\usepackage{url}


\newcommand{\effects}{\noindent \textbf{Effects:}}
\newcommand{\returns}{\noindent \textbf{Returns:}}
\newcommand{\returntype}{\noindent \textbf{Return type:}}
\newcommand{\requires}{\noindent \textbf{Requires:}}
\newcommand{\notes}{\noindent \textbf{Notes:}}
\newcommand{\values}{\noindent \textbf{Value:}}
\newcommand{\example}{\noindent \textbf{Example:}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\req}[1]{\noindent \textbf{#1}}

\newcommand{\concept}[1]{\textsf{#1}}

%\author{Jaakko Järvi}

\title{Proposal for adding tuple types into the standard library\\ \large{Document no: N1382=02-0040}}


\begin{document}
\maketitle{}

\section{Motivation}

Tuple types exist in several programming languages, such as Haskell, 
ML, Python, Eiffel, to name a few. Tuple types are fixed size heterogeneous 
containers. They are a general purpose utility, 
adding to the expressiveness of the language. Some examples of 
common uses for tuple types are:
\begin{itemize}
\item Return types of functions that need to have more than one return type.
\item Grouping related types or objects (such as parameter lists) into a single entity.
\item Simultaneous assignment of multiple values.
\end{itemize}

This proposal describes tuple types for C++. 
The standard library provides the \code{pair}
template which is being used throughout the standard library, demonstrating 
the usefulness of tuple-like constructs.
The proposed tuple type is basically a generalization of the \code{pair} 
template from two to arbitrary (up to a predefined limit) number of elements.
Compared to pairs, the proposed tuples:
\begin{itemize}
\item Support a wider range 
of element types (e.g. references).
\item Support input from and output to a stream, customizable
with specific manipulators.
\item A mechanism for 'unpacking' tuple elements into stand alone variables 
(\code{tie} functions).
\end{itemize}

\section{Impact on the standard}

All features described in this document can be implemented as a library,
without requiring any core language changes.
However, the implementation would benefit from a set of core language changes:
\begin{itemize}
\item Variable length template argument lists.
\item Making reference to a reference to some type \code{T} equal to 
reference to \code{T} (core language issue 106).
\item Allowing default arguments (both template and function) for function
templates (core language issue 226).
\item Ignoring cv-qualifiers that are added to function types (core language issue 295).
\end{itemize}
%
Furthermore, even within the current language
there are at least a few different approaches for implementing
tuples underneath a common interface.

For these reasons we do not suggest a fixed implementation be standardized, 
but rather the proposed text for the standard states the requirements for
a tuple implementation 
in the form of valid expressions and the semantics of these expressions.

Another reason for this approach is that it leaves
room for a built-in tuple type, or for a tuple template with some special
support from the compiler, which we see worth considering.
A library solution still falls short in some aspects, 
compared to built-in tuple types in other languages.
For instance, in Python and Haskell ???, the function argument list is 
implicitly a tuple.
This is a feature that cannot be built into C++ as a library.
Tuples as built-in types are discussed more in section~\ref{Built-in tuples}.

In sum, this proposal defines the requirements for a tuple type 
to be implemented as a library.
The requirements are stated as to allow a future transition to 
a more feature-rich built-in tuple type.

The concrete additions and changes to the standard are:
\begin{itemize}
\item A new section describing the requirements for the tuple template
\item Backward compatible changes to \code{pair} to allow pairs act
as tuples.
\item An utility class and two utility function templaets to be used in passing
reference arguments through a pass-by-copy interface.
These templates have uses outside of tuples and should thous be described
elsewhere in the standards, possibly together with the type\_traits library~\cite{cit:boost_type_traits:02,cit:maddock:00}, which has been suggested for
standardization~\cite{type_traits_proposal}.
\end{itemize}

We propose tuple definitions to be included by including the \code{<utility>} 
header, which is where \code{pair} resides in.
However, operators for reading tuples from a stream and writing tuples into
a stream do introduce a dependency to \code{<istream>} and \code{<ostream>},
hence a new header \code{<tupleio>} is proposed.

\section{Tuples in a nutshell}

The purpose of this section is to give an informal overview of the 
features that the tuple types, implemented as a library, provide.

\subsection{Defining tuple types}

The \code{tuple} template can be instantiated with any number of arguments
from 0 to some predefined upper limit. In the Boost Tuple library~\ref{boost_tuples}, this limit is 10.
The argument types can be any valid C++ types.
Examples:
\begin{verbatim}
typedef tuple<A, const B, volatile C, const volatile D> t1;
typedef tuple<int, int&, const int&, const volatile int&> t2;
typedef tuple<void, int()(int)> t3;
\end{verbatim}
Note that even types of which no objects can be created (cf. \code{void}, \code{int()(int)}), are valid tuple elements.
Naturally an object of a tuple with such an element type cannot be created 
either (see~\ref{about_valid_element_types}).

\subsection{Constructing tuples}

A $n$ element tuple has a default constructor, 
a constructor with $n$ parameters, 
a copy constructor and a \emph{converting copy constructor}.
With converting copy constructor we refer to a constructor that 
can construct a tuple from another tuple, as long as the type of each element
of the source tuple is convertible to the type of the corresponding 
element of the target tuple.

The types of the elements restrict which constructors can be used:
\begin{itemize}
\item If an $n$-element tuple is constructed with a constructor taking 
0 elements, all elements must be default constructible.
For example:
\begin{verbatim}
tuple<int, float> a; // ok
class no_default_constructor{ no_default_constructor(); };
tuple<int, no_default_constructor, float> b; // error
tuple<int, const int&> c; // error, references cannot be default constructed
\end{verbatim}

\item If an $n$-element tuple is constructed with a constructor taking 
$n$ elements, all elements must be copy constructible and convertible
(default initializable) from the corresponding argument.
For example:
\begin{verbatim}
tuple<int, const int, std::string>(1, 'a', "Hi")
tuple<int, std::string>(1, 2); // error
\end{verbatim}

\item If an $n$-element tuple is constructed with the converting copy 
constructor, each element must be elementwise copy constructible.
%
\begin{verbatim}
tuple<char, int, const char(&)[3]> t1('a', 1, "Hi");
tuple<int, float, std::string> t2 = t1; // ok
\end{verbatim}
\end{itemize}

\subsection{\code{make\_tuple}}

Tuples can also be constructed using the \code{make\_tuple} 
(cf. \code{make\_pair}) helper functions. 
This makes the construction more convenient, saving the programmer 
from explicitly specifying the element types:
%
\begin{verbatim}
tuple<int, int, double> add_multiply_divide(int a, int b) {
  return make_tuple(a+b, a*b, double(a)/double(b));
}
\end{verbatim}
%
By default, the element types are deduced to the plain non-reference types. 
E.g the \code{make\_tuple} invocation below creates a tuple of type
\code{tuple<A, B>}:
\begin{verbatim}
void foo(const A& a, B& b) { 
  ...
  make_tuple(a, b);
\end{verbatim}
%
This default can be changed with to utility functions \code{ref} 
and \code{cref}.
An argument wrapped with \code{ref} will cause the element type to be 
a reference to the argument type, and \code{cref} respectively a reference
to const argument type. 
For example:
%
\begin{verbatim}
A a; B b; const A ca = a;
make_tuple(cref(a), b);      // constructs tuple<const A&, B>(a, b)
make_tuple(ref(a), b);       // constructs tuple<A&, B>(a, b)
make_tuple(ref(a), cref(b)); // constructs tuple<A&, const B&>(a, b)
make_tuple(cref(ca));        // constructs tuple<const A&>(ca)
make_tuple(ref(ca));         // constructs tuple<const A&>)ca)
\end{verbatim}
%
Array arguments to \code{make\_tuple} result in the corresponding typle element
being a reference to a const array. 
This is to avoid the need to wrap arrays with \code{cref}, as arrays cannot
be copied as such anyway.

Note, \code{make\_tuple} cannot be made to accept references to function 
types without the \code{ref} wrapper, unless the issue XXX gets resolved.

\subsection{Assignment}

The assignment operation is defined as elementwise assignment.
Consequently, two tuples are assignable as long as they are elementwise 
assignable.
For example:
\begin{verbatim}
tuple<char, int, const char(&)[3]> t1('a', 1, "Hi");
tuple<int, float, std::string> t2;
t2 = t1; // ok
\end{verbatim}

\subsection{Tiers}

Tiers are tuples, where all elements are of non-const reference types. 
They are constructed with a call to the \code{tie} function template 
(cf. \code{make\_tuple}):
\begin{verbatim}
int i; char c; double d; 
tie(i, c, a);
\end{verbatim}
%
The above \code{tie} function invocation creates a tuple of type 
\verb|tuple<int&, char&, double&>|. 
A tuple that contains non-const references as elements can be used to 
'unpack' another tuple into variables. 
For example:
%
\begin{verbatim}
int i; char c; double d; 
tie(i, c, d) = make_tuple(1,'a', 5.5);
\end{verbatim}
After the assignment, \code{i == 1}, \code{c == 'a'} and \code{d == 5.5}.
A tuple unpacking operation like this is found for example in ML and Python. 
It is convenient when calling functions which return tuples.

%The tying mechanism works with std::pair templates as well:
%
%int i; char c;
%tie(i, c) = std::make_pair(1, 'a');

\subsubsection{Ignore}

There library provides an object called \code{ignore} which allows one 
to ignore elements in an assignment to a tier. 
Any assignment to \code{ignore} is a no-operation.
For example:
\begin{verbatim}
char c;
tie(tuples::ignore, c) = make_tuple(1, 'a');
\end{verbatim}

\subsection{Number of elements}

Tuples make the number of element accessible as a compile time constant 
\code{size}.
\begin{verbatim}
tuple<int, int, int, int>::size; // equals 4
\end{verbatim}

\subsection{Element type}

The type of the \code{N}th element can be accessed as a typedef within
a template \code{tuple\_element}:
\begin{verbatim}
tuple_element<2, tuple<int, char, float, double> >::type // float
\end{verbatim}
Indexing is zero based. The index must be an integral constant expression
and index out of bounds results in a compile time error.
See section~\ref{nested_or_separate} for a discussion about
why a separate, instead of a nested class in the tuple template.


\subsection{Element access}

Let \code{t} be a tuple object. 
The expression \code{get<N>(t)} returns the reference to the \code{N}th 
element of \code{t}, where \code{N} is an integral constant expression.
\begin{verbatim}
tuple<int, float, char>(1, 3.14, 'a') t;
get<2>(t); // equals 'a'
\end{verbatim}
Indexing is zero based. Index out of bounds results in a compilation error.
The section~\ref{element_access} discusses alternatives for the
syntax of element access.

\subsection{Relational operators}

Tuples reduce the operators \code{==}, \code{!=}, \code{<}, \code{>}, 
\code{<=} and \code{>=} to the corresponding elementary operators. 
This means, that if any of these operators is defined between all elements of 
two tuples, then the same operator is defined between the tuples as well. 

The \code{operator==} is defined as the logical and of the elementwise 
equality comparisons.
The \code{operator!=} is defined as the logical or of the
elementwise comparisons.
The operators \code{<}, \code{>}, \code{<=}, \code{>=} each define a 
lexicographical ordering (see section~\ref{lexicographical_ordering}).

Each comparison operator \emph{op} is defined solely using the same
operator \emph{op} for the elementwise comparisons and makes no assumptions
about the behaviour respect to the other relational operators, or even
to whether they are defined or not.

The operators \code{<}, \code{>}, 
\code{<=} and \code{>=} implement a lexicographical ordering.
An attempt to compare two tuples of different lengths results in 
a compile time error.
The comparison operators are "short-circuited": elementary comparisons 
start from the first elements and are performed only until the result is clear.

Examples: 
\begin{verbatim}
tuple<int, float, char> t(1, 2, 'a'); 
tuple<int, char, int> u(1, 1, 1000;
t < u; // ok, false 

tuple<int, int, int, int> x;
tuple<int, int, int> y; 
x < y; // error, different size

tuple<int, int, complex<double>, int> x;
tuple<int, int, string, int> y; 
x < y; // error, no operator< between complex<double> and string
\end{verbatim}


\subsection{Input and output}

The library overloads the streaming operators \verb|<<| and \verb|>>| for 
tuples. Output is impelemnted by invoking \code{operator<<} for each element,
and input respectively with invocations to \code{operator>>}.
Additionally, an opening and a closing 
character, and a delimiter character between each two consequtive elements 
are written to the stream when writing out a tuple.
Respectively, the same characters are expected to be present when extracting
tuples from an input stream.
The default delimiter between the elements is space, and the default opening
and closing charcters are the parenthesis.
For example:
\begin{verbatim}
cout << make_tuple(1, 'a', "C++");
\end{verbatim}
outputs \code{(1 a C++)}.

The library defines three manipulators, \code{tuple\_open}, 
\code{tuple\_close} and \code{tuple\_delimiter} to change, respectively, 
the opening, closing and delimiter characters for a particular stream.
For example:
\begin{verbatim}
cout << tuple_open('[') << tuple_close(']') << tuple_delimiter(',') 
     << make_tuple(1, 'a', "C++");
\end{verbatim}
outputs the same tuple a as: \code{[1,a,C++]}.

Note that in general it is not guaranteed that a tuple written to 
a stream can be extracted back to a tuple of the same type, since the 
streamed tuple representation may not be unambiguosly pareseable.
This is true for instance for tuples with \code{string} or C-style string 
element types.

\subsection{Performance}

Based on the experience with the Boost Tuple library, 
it is reasonable to expect an optimizing compiler to eliminate any extra cost 
of using tuples compared to using hand written tuple like classes.
Inlining and copy propagation are the optimizations required to attain 
this goal.

Concretely, accessing tuple members should be as efficient as accessing
a member variable of any class.
Further, constructing a tuple should have no other cost than the cost
of constructing the elements as separte objects.
The same should be true for assignment.
To actually require this for a standard conforming implementation
might be too drastic.


\part*{Text in the standard}

Text enclosed with brackets and typeset in sans serif is
a comment, not propsed standard text \textsf{[This is a comment]}.
\section{Annex B: Implementation quantites}

\textsf{[Add to the list of implementation quantities:]}

--- Number of elements in one tuple type [10].

\section{Tuple Library}

The library provides a tuple type as 
the class template \code{tuple} that can be instantiated with any number
of arguments.
The implementation can set an upper limit for the number of arguments.
Each template argument specifies the type of an element in the \code{tuple}.
Consequently, tuples are heterogeneous fixed size collections of values. 

Implementations are allowed to define the tuple template as an interface
that inherits from some templated base class \code{T}, which stores
the tuple elements.
Such a template \code{T} is referred to as \code{tuple implementation 
template}.
Further, implementations are allowed to define
the functions that operate on tuple types 
(comparison operators, \verb|>>| and \verb|<<|
operators for input and output, element access functions) 
overloaded for the tuple implementation template instead of the \code{tuple} 
template, provided that instances of the tuple implementation template
fulfill the requirements for tuple types stated below.

\smallskip 

\begin{sf}
\noindent [The tuple template has a large number of template parameters (10) 
or more, and it is thus tedious to overload functions for such a type.
In a reasonable implementation, the \code{tuple} interface class inherits 
from another template (say a cons list) which only has two template
parameters and represents tuples as a recursive instantiations of the
same template. 
The tuple operations can be defined much more succinctly for 
such recursively defined types.
See~\cite{cit:boost_tuple_library:01,jarvi:01:cuj_tuples} for an example.

However, this affects the way overload resolution works.
If some type \code{B} inherits from an instance of some template 
\code{A<T>}, a function with a fully generic interface is a better match
for \code{B} than a function overloaded for \code{A<T>}.
E.g.:
\begin{verbatim}
template <class T> void foo(const T& t); 
template <class T> void foo(const A<T>& t); 
class B : public A<int> {};
B b; 
foo(b); // calls the first, fully generic definition of foo
\end{verbatim}
overloading rules for templates make a fully generic template
function (\verb|template <class T> foo(const T& t)|) a better match.

Considering the subtlety of the way overload resolution works in this case, 
the explicit mention that the implementation is allowed to define the operators
with a function that is a worse match than a fully generic function,
is in order.
]
\end{sf}

\smallskip 

%The requirements for such a \emph{tuple implementation template} 
%are, that it must have the same observable behaviour than referes to such 
%an implementation template, or to the tuple template if no 
%The implementation template mustIf \code{T} all the elements as provides all the functionality provided, and overload tuple operations (converting copy
%constructors, assignments, conversion operators, etc.) for the \code{T}
%templates, instead of \code{tuple} templates.

The following subclauses describe the requirements for the tuple
type.


\subsection{Notation}

\begin{tabular}{lp{10cm}}
\code{T}, \code{U} & are tuple types\\
\code{t}, \code{u} & objects of types \code{T} and \code{U}\\
\code{tc}, \code{uc} & objects of types \code{const T} and \code{const U}\\
\code{p} & an object whose type is a potentially cv-qualified instance of \code{pair}, or whose type inherits from a potentially cv-qualified instance of \code{pair}. (JAAKKO, make this shorter)\\
\code{T$_i$} & the type of the $i$th element in \code{T}\\
\code{t$_i$} & the $i$th element of \code{t}
For all $i$ in \code{T} & For all indices $i$ in ...
\end{tabular}

\noindent The notation \code{T1, T2, ..., TN} 
stands for a comma separated list of
types which may contain any number of elements from 0 to \code{N},
where \code{N} $\le$ maximum number of allowed tuple elements. 
The notation \code{t, t2, ..., tn} is an analogous list of objects.


\subsection{Valid Expressions}


\subsubsection*{Compile time expressions}


\hspace{\parindent} \code{is\_tuple<T>::value}

\smallskip

\req{Type:} static const bool (integral constant expression).\\
\req{Value:} \code{true} if \code{T} is, or derives, from an instance of 
the tuple implementation class.

\medskip 

\code{tuple\_size<T>::value}

\smallskip

\req{Type:} \code{static const int} (integral constant expression).\\
\req{Value:} Number of elements in \code{T}. Number of elements for non-tuple
types is 1.


\medskip

\code{tuple\_element<N, T>::type}

\smallskip 

\requires\ 0 $\le$ \code{N} $<$ \code{tuple\_size<T>::value}.\\ 
\values\ The type of the \code{N}th element of \code{T}, where
indexing is zero-based.
If \code{T} is a non-tuple type and \code{N == 0}, value is \code{T}.


\subsubsection*{Element access}

\hspace{\parindent} \code{get<N>(t)}

\smallskip 

\req{Requires:} 0 $\le$ \code{N} $<$ \code{tuple\_size<T>::value}.\\
\req{Return type:} \code{tuple\_element<N, T>::type\&}.\\
\textsf{[Assuming core issue 106 is resolved to make a reference to a 
reference be just a reference instead of an error.
Otherwise, the return type must be defined as: \code{add\_reference<tuple\_element<N, T>::type>::type}.
This same note applies to elsewhere (JAAKKO: precisely where)]}\\
\returns\ A reference to the \code{N}th element of \code{t}, where
indexing is zero-based.

\medskip

\code{get<N>(tc)}

\smallskip 

\requires\ 0 <= \code{N} < \code{tuple\_size<T>::value}.\\
\returntype\ \code{const tuple\_element<N, T>::type\&}.\\
\returns\ A reference to the \code{N}th element of \code{tc}, where indexing is
zero based.\\
\notes\ Constness is shallow. If \code{element\_type<N, T>::type} is some
reference type X\&, the return type is X\&, not const X\&. \\
\textsf{[This is consistent how constness is defined to work for
reference member variables}].

\begin{itemize}
\item Assignment

\code{t = u}\\
\requires\ \code{T::size == U::size}. For all $i$, \\
\code{t$_i$ = u$_i$} is a valid expression.\\
\effects\ Performs \code{t$_i$ = u$_i$} for all $i$.\\
\returntype\ \code{T\&}.\\
\returns\ \code{t}.

\code{t = p}\\
\requires\ \code{T::size == 2}. \code{t$_i$ = p.first} and 
\code{t$_i$ = p.second} are valid expressions.\\
\effects\ as if implemented: \code{t$_i$ = p.first; t$_i$ = p.second;}.\\
\returntype\ \code{T\&}.\\
\returns\ \code{t}.

\item Equality comparison

\code{t == u}, \code{t = uc}\\
\requires\ \code{T::size == U::size}. For all $i$, \\
\code{t$_i$ == u$_i$} is a valid expression returning a type that is
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ \code{true} iff {t$_i$ == u$_i$} for all $i$.
For any two empty tuples \code{e} and \code{f}, \code{e == f} returns \code{true}.



\item Inequality comparison

\code{t != u}\\
\requires\ \code{T::size == U::size}.
For all $i$, 
\code{t$_i$ != u$_i$} is a valid expression returning a type that is 
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ \code{true} iff {t$_i$ != u$_i$} for some $i$.
For any two empty tuples \code{e} and \code{f}, \code{e != f} returns \code{false}.

\item \code{<}, \code{<=}, \code{>}, \code{>=} comparisons

\code{t $\bullet$ u}, where \code{$\bullet$} is one of \code{<}, \code{<=}, \code{>}, 
\code{>=}\\
\requires\ \code{T::size == U::size}. For all $i$, 
\code{t$_i$ $\bullet$ u$_i$} and \code{u$_i$ $\bullet$ t$_i$} are valid expressions 
returning a type that is 
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ The result of a lexicographical comparison with \code{$\bullet$} between \code{t} and \code{u}, as if implemented:

\code{t$_i$ $\bullet$ u$_i$ || !((bool)(u$_i$ $\bullet$ t$_i$)) \&\&
                       t$_{\mathrm{tail}}$ $\bullet$ u$_{\mathrm{tail}}$}, where \code{r$_{\mathrm{tail}}$}
	is a tuple containing all but the first element of \code{r}.




\item Construction

\verb|tuple<T0, T1, ..., TN>()|\\
\requires\ Each element type can be default constructed.\\
\effects\ Default initializes each element.

\verb|tuple<T0, T1, ... TN>(t0, t1, ..., tN)|\\
\requires\ Each element type \code{Ti} type is
\concept{CopyConstructible}. JAAKKO: Are all requirements of CopyConstructible
required, probably not. Also, maybe even copy constrcution is required only
for some types that match directly. And what are references to copy constructible?
The type of each \code{ti} is convertible to \code{Ti}.\\
\effects\ Copy initializes each element with the value of the corresponding 
parameter.

\verb|tuple<T0, T1, ... TN>(u);|\\
\requires\ Each element type \code{Ti} is \concept{CopyConstructible},
(JAAKKO, see above). 
\code{u} has \code{N} elements. 
For each element index $i$, the type of \code{u$_i$} is 
convertible to \code{Ti}.\\
\effects\ Copy initializes each element $i$ with \code{u$_i$}.

\verb|tuple<T0, T1>(p)|, where \code{p} is an object of
of type \code{pair<X, Y>} (JAAKKO: or inhertis from one).\\
\requires\ \code{X} is convertible to \code{T0}, \code{Y} is convertible to 
\code{T1}.\\
\effects\ Copy initializes the first element with \code{t.first} and the 
second with \code{t.second}.

\item Input and output

\verb|os << t|, where \code{os} is an instance of \code{basic\_ostream} (JAAKKO, say somewhere, that is instance of means that is instance of or inherits
publicly from an instance of).\\
\requires\ For all $i$, \verb|os << t|\code{$_i$} is a valid expression.\\
\effects\ Inserts \code{t} into \code{os} as \code{$L$t$_1$$d$t$_2$$d$...$d$t$_n$R}, where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple manipulators.
Each element \code{t$_i$} is output by invoking \verb|os << t|\code{$_i$}.\\
\returntype\ \code{basic\_ostream}. (JAAKKO, say this differently)\\
\returns\ \code{os}.

\verb|is >> t|, where \code{is} is an instance of \code|basic\_istream| (JAAKKO, say somewhere, that is instance of means that is instance of or inherits
publicly from an instance of).\\
\requires\ For all $i$, \verb|is >> t|\code{$_i$} is a valid expression.\\
\effects\ Extracts a tuple of the form \code{$L$t$_1$$d$t$_2$$d$...$d$t$_n$R},
where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple manipulators.
Each element \code{t$_i$} is extracted by invoking \verb|is >> t|\code{$_i$}.
If bad input is encountered, calls \code{is.set\_state(ios::failbit)} (which
may throw \code{ios::failure} (27.4.4.3).\\
\returntype\ \code{basic\_istream}. (JAAKKO, say this differently)\\
\returns \code{is}.

\item Manipulators

The type designated \emph{tuple\_manip} in the following function descriptions
is implementation-specified and may be
different for each function.

\emph{tuple\_manip} \code{tuple\_open(char\_type c)}\\
\emph{tuple\_manip} \code{tuple\_close(char\_type c)}\\
\emph{tuple\_manip} \code{tuple\_delimiter(char\_type c)}\\
\returns\ Each of these functions returns an object \code{s} of unspecified 
type such that if \code{out} is an 
instance of \code{basic\_ostream<charT,traits>}, \code{in} is an instance of
\code{basic\_istream<charT,traits>} and \code{c} has type \code{charT},
then expression \verb|out << s| (respectively \verb|in >> s|) 
sets \code{c} to be
the opening, closing, or delimiter character (depending on the manipulator
function called) to be used when writing tuples into \code{out} (respectively
reading extracting tuples from \code{in}).\\
\notes\ Implementation is not required to support these manipulators for 
streams with \code{sizeof(charT) > sizeof(long)}; if not supported,
\verb|out << s| and \verb|in >> s| are required to fail at compile time if
\code{out} are \code{in} are such streams.

\item Functions for helping in tuple construction

The library provides class template \code{any\_holder} that can hold
objects or references of any type. 
Reference types wrapped in \code{any\_holder} can be passed by copy, and
as const reference, whithout affecting the constness of the wrapped object.
Two template functions, \code{ref} and \code{cref} are provided to create
\code{any\_holder} objects.
The observable behaviour of \code{any\_holder}, \code{ref} and \code{cref}
must be as if implemented:
\begin{verbatim}
template <class T>
class any_holder {
  T data;
//  typedef typename add_reference<typename add_const<T>::type>::type par_t;
  typedef const T& par_t;
public:
  operator T() { return data; }
  T unwrap() { return data; }

  explicit any_holder(par_t t) : data(t) {}
};

template <class T> inline any_holder<T&> ref(T& t) { 
  return any_holder<T&>(t); 
}

template <class T> inline any_holder<const T&> cref(const T& t) { 
  return any_holder<const T&>(t); 
}
\end{verbatim}

\code{make\_tuple(t1, t2, ..., tn)}\\
\returntype\ \code{tuple<T1, T2, ..., TN>}, where 
if \code{Vi} is the non-reference type of \code{ti}
\begin{itemize}
\item \code{Vi} is an array type, then \code{Ti} is a reference \code{const Vi}.(JAAKKO. can one add const to an array type)
\item if the cv-unqualified type of \code{Vi} is \code{any\_holder<X>},
then \code{Ti} is \code{X}.
\item otherwise \code{Ti} is \code{remove\_const<Vi>::type}.
\end{itemize}
\example\ \verb|int i; float j; make_tuple(1, "C++", ref(i), cref(j))| creates
a tuple of type \verb|tuple<int, const char (&) [4], int&, const float&>|.
\notes\ To construct a tuple which contains a reference to a function, the 
function reference must be wrapped inside \code{ref}.

\code{tie(t1, t2, ..., tn)}\\
\effects\ As if implemented:
\begin{verbatim}
template<class T1, class T2, ..., class TN>
tuple<T1&, T2&, ..., TN&> tie(T1& t1, T2& t2, ..., TN& tn) {
  return tuple<T1&, T2&, ..., TN&>(t1, t2, ..., tn); 
}
\end{verbatim}
%
for each \code{N} from 0 to the maximum number of allowed tuple elements.

The library provides an object
\code{ignore} of some implementation-specified type \emph{swallow\_assignment}.

\code{ignore = k}, where \code{k} referes to an object of arbitrary type.\\
\effects\ No effect.\\
\returntype\ \emph{swallow\_assignment}\code{\&}\\
\notes\ \code{k} may not be a reference to a function, unless rule XXX 
is changed.

\example\ \code{tie} functions let one create tuples that unpacks another 
tuple object into variables. \code{ignore} can be used for elements that
are not needed:
\begin{verbatim}
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, , 3.14, "C++");
// i == 42, s == "C++";
\end{verbatim}
\end{itemize}

\bibliography{tuple_proposal}
\bibliographystyle{plain}

\end{document}

\section{Discussion about design}

\subsection{About valid element types\label{about_valid_element_types}}

The proposed requirements state, that there are no restrictions on the types
of tuple elements, if the program contains no construction invocations 
for the tuple type.
For example, \code{void} and \code{int()()} are valid C++ types, but 
objects of these types can never be created. 
Hence, \code{tuple<void, int()()>} is a valid tuple type but obviously an
object of this type cannot be constructed.

A straightforward implementation, where the type of a template
parameter is a type of a member variable, does not fullfil the above
restriction. The types of the member variables are checked when the template 
is instantiated, and \code{void} and function types are rejected as member
types, even though an object is never constructed.

The way to cope with this issue is to transform each member through
a traits class, wrapping \code{void} and function types to something 
that can be a member variable, but cannot be constructed.

This means extra clutter in the code implementing tuple types, but
we find the feature important for uniformness. 
Otherwise, tuple types would impose a restriction, that does not exist
for the element types.

\subsubsection{Defining constructors, assignments, and other operators for just tuples or for any conforming type}

\subsubsection{Element type as a nested or separate class template\lable{nested_or_separate}}

\subsubsection{About element access\label{element_access}}

\subsubsection{About comparison operators\label{lexicographical_ordering}

Mathematically wrong for product types, but practical.
(JAAKKO: stick somewhere justification, std::pair,
Haskell)

\code{About tuples as built-in types}

Particularly, many languages consider the argument list to a function to
be implicitly a tuple object (lanXXX, langYYY).
This would be a remarkable improvement for generic programming in C++, 
making truly generic wrapping, delegating, or forwarding functions possible.
For example, the problem of not being able to inherit constructors would
cease to exist, as one could define a constructor taking any tuple, and
forward the tuple to the base class.

Another important point EIFFEL, 
Also, it is should be noted, that the programming language Eiffel does not
allow varying number of generic parameters, except for tuple tuple types.
The author is personally convinced that a built-in tuple type, with argument
list of a function being implicitely a tuple object, and a mechanism to 
(More on appendix)


- Miksi assignment riittää paireista tupliin
- Mikä on tuple_size:n return type


The tuple type is impelemented as an interface template \code{tuple} that
can take up to $n$ (10 in the reference implementation) template arguments.
It is very tedious to overload functions for such a verbose type.
Consequently, the \code{tuple} interface class inherits from instantiations
of another type (\code{cons}) which represents the tuple element as a 
\emph{cons list}.
Comparison operators, streaming operators and element accessor functions all 
operate on the cons list representation.

We propose this representation be standardized as well, to give end programmers
a convenient way to overload functions for tuple types. 



\begin{verbatim}
cons(const typename remove_volatile<head_type>::type& h, 
     const tail_type& t);
\end{verbatim}
\requires{All elements are \concept{CopyConstructible}}.
\effects\ Initializes \code{head\_} with \code{h}
and \code{tail\_} with \code{t}.\\
\notes\ 
Unless \code{head\_type} is a non-const reference type, it is allowed 
to call the constructor with a temporary as the first argument.
When binding temporaries to references, the reference must
be to a non-volatile and const type (8.5.3 (5)). Thus \code{volatile}
is removed and \code{const} added. Reference types stay intact.


\begin{verbatim}
template <class H2, class T2> cons(const cons<H2, T2>& u);
\end{verbatim}

\effects\ Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.



\begin{verbatim}
cons& operator=(const cons& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}\\
\notes\ Default assignment operator is illformed if a class contains
member variables of reference types (12.8 (12)). 
Therefore an explicit definition is needed.

\begin{verbatim}
template <class T1, class T2> cons& operator=(const std::pair<T1, T2>& u);
\end{verbatim}
\requires\ \code{tuple\_size<cons> == 2} (ref????).\\
\effects\ As if implemented: 
\code{*this.head\_ = u.first; *this.tail\_.head\_ = u.second;}\\
\returns\ \code{*this}


\returns\ Reference to \code{head\_}.\\
\notes\ Constness is shallow. If \code{head\_type} is a non-const reference 
type, returns a non-const reference.





Osat:

- introduction to tuples

- text in standard

- reference implementation

- about the reference implementation


TODO:

- laita comparison-operaattoreihin conversion to bool before ! operator
-  change static cast to reintepret cast in or something in manipulators

- PREPROCESSOR_CONSTANT for max tuple length
- traits: (no limit)


