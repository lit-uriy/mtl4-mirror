\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

%\usepackage[finnish]{babel}

\usepackage{url}
\usepackage{alltt}

\usepackage{ae}

\newcommand{\cccomment}[1]{\textrm{\textit{#1}}}

\newcommand{\effects}{\noindent \textbf{Effects:}}
\newcommand{\returns}{\noindent \textbf{Returns:}}
\newcommand{\returntype}{\noindent \textbf{Return type:}}
\newcommand{\requires}{\noindent \textbf{Requires:}}
\newcommand{\notes}{\noindent \textbf{Notes:}}
\newcommand{\values}{\noindent \textbf{Value:}}
\newcommand{\example}{\noindent \textbf{Example:}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\req}[1]{\noindent \textbf{#1}}

\newcommand{\concept}[1]{\textsf{#1}}

\author{Jaakko Järvi\\
Indiana University\\
Pervasive Technology Laboratories\\
Bloomington, IN\\
{\em jajarvi@cs.indiana.edu}}


\title{Proposal for adding tuple types into the standard library\\ \large{Programming Language C++}\\ \large{Document no: N1382=02-0040}}


\begin{document}
\maketitle

\markboth{Doc. no: N1382=02-0040}{Doc. no: N1382=02-0040}

\pagestyle{myheadings}


\section{Motivation}

Tuple types exist in several programming languages, such as Haskell, 
ML, Python and Eiffel, to name a few. 
Tuples are fixed-size heterogeneous 
containers. They are a general-purpose utility, 
adding to the expressiveness of the language. Some examples of 
common uses for tuple types are:
\begin{itemize}
\item Return types for functions that need to have more than one return type.
\item Grouping related types or objects (such as entries in parameter lists) 
into single entities.
\item Simultaneous assignment of multiple values.
\end{itemize}

This proposal describes tuple types for C++. 
The standard library provides the \code{pair}
template which is being used throughout the standard library, demonstrating 
the usefulness of tuple-like constructs.
The proposed tuple type is basically a generalization of the \code{pair} 
template from two to an arbitrary number of elements.
In addition to the features and functionality of pairs, 
the proposed tuple types:
\begin{itemize}
\item Support a wider range 
of element types (e.g. reference types).
\item Support input from and output to streams, customizable
with specific manipulators.
\item Provide a mechanism for `unpacking' tuple elements into separate variables.
\end{itemize}

\section{Impact on the standard}

All features described in this document can be implemented in a library,
without requiring any core language changes.
However, the implementation would benefit from a set of core language changes:
\begin{itemize}
\item Adding support for variable-length template argument lists.
\item Making a reference to a reference to some type \code{T} equal to 
a reference to \code{T} (core language issue 106).
\item Allowing default template arguments for function
templates (core language issue 226).
\item Ignoring cv-qualifiers that are added to function types (core language issue 295).
\item Adding support for templated typedefs.
\end{itemize}
%
There are at least a few different approaches for implementing
tuples underneath a common interface.

For these reasons we do not suggest that a fixed implementation 
be standardized, 
but rather that the proposed text for the standard state the requirements for
a tuple implementation 
in the form of valid expressions and the semantics of those expressions.
Also, this approach leaves
room for a built-in tuple type, or for a tuple template with special
support from the compiler, which we see as being worth considering.
Compared to built-in tuple types in other languages,
a library solution still falls short in some aspects.
For instance, in the programming language Python, 
the function argument list is implicitly a tuple.
This is a feature that cannot be added to C++ as a library, but
would be most useful.\footnote{Truly generic forwarding functions
that could take any number of parameters would be supported. For example, one constructor 
definition in a derived class could cover a large set of base class 
constructors with different arities and argument types.}
%Tuples as built-in types are discussed more in section~\ref{built-in_tuples}.

In sum, this proposal defines the requirements for a standard tuple type.
The requirements are stated so as to allow a library implementation with the
current language, but also
a future transition to 
a more feature-rich built-in tuple type, or to a library implementation
that can take advantage of new language features, such as variable length
template argument lists or templated typedefs.

The concrete additions and changes to the standard are:
\begin{itemize}
\item A new section describing the requirements for the tuple template.
\item Backwards-compatible changes to \code{pair} to allow pairs to act
as tuples.
\item A utility class and two utility function templates to be used in passing
reference arguments through a pass-by-copy interface.
These templates have uses outside of tuples and should thus be described
elsewhere in the standard, possibly together with the \emph{type traits} library~\cite{cit:boost_type_traits:02,cit:maddock:00}, which has been proposed for
standardization~\cite{cit:type_traits_proposal:02}.
\end{itemize}

We propose two new standard headers. 
The basic tuple definitions are to be included by including the \code{<tuple>} 
header.
Operators for reading tuples from a stream and writing tuples to
a stream introduce a dependency to \code{<istream>} and \code{<ostream>},
and so tuple input and output operators will be defined in a separate header
\code{<tupleio>}.

\section{Tuples in a nutshell}

The purpose of this section is to give an informal overview of the 
features that the tuple types provide.
The feature set is largely based on the Boost Tuple 
Library~\cite{cit:boost_tuple_library:01,jarvi:01:cuj_tuples}.

\subsection{Defining tuple types}

The \code{tuple} template can be instantiated with any number of arguments
from 0 to some predefined upper limit. In the Boost Tuple library, this limit is 10.
The argument types can be any valid C++ types.
For example:
\begin{verbatim}
typedef tuple<A, const B, volatile C, const volatile D> t1;
typedef tuple<int, int&, const int&, const volatile int&> t2;
typedef tuple<void, int()(int)> t3;
\end{verbatim}
Note that even types of which no objects can be created (cf. \code{void}, \code{int()(int)}), are valid tuple elements.
Naturally, an object of a tuple type with such an element type cannot 
be constructed. 
%(see section~\ref{about_valid_element_types}).

\subsection{Constructing tuples}

An $n$-element tuple has a default constructor, 
a constructor with $n$ parameters, 
a copy constructor and a \emph{converting copy constructor}.
By converting copy constructor we refer to a constructor that 
can construct a tuple from another tuple, as long as the type of each element
of the source tuple is convertible to the type of the corresponding 
element of the target tuple.
%
The types of the elements restrict which constructors can be used:
\begin{itemize}
\item If an $n$-element tuple is constructed with a constructor taking 
0 elements, all elements must be default constructible.
For example:
\begin{alltt}
tuple<int, float> a; // \cccomment{ok}
class no_default_constructor \{ no_default_constructor(); \};
tuple<int, no_default_constructor, float> b; // \cccomment{error}
tuple<int, int&> c; // \cccomment{error, no default construction for references}
\end{alltt}


\item If an $n$-element tuple is constructed with a constructor taking 
$n$ elements, all elements must be copy constructible and convertible
(default initializable) from the corresponding argument.
For example:
\begin{alltt}
tuple<int, const int, std::string>(1, 'a', "Hi")
tuple<int, std::string>(1, 2); // \cccomment{error}
\end{alltt}

\item If an $n$-element tuple is constructed with the converting copy 
constructor, each element type of the constructed tuple type must
be convertible from the corresponding element type
of the argument. 
\begin{alltt}
tuple<char, int, const char(&)[3]> t1('a', 1, "Hi");
tuple<int, float, std::string> t2 = t1; // \cccomment{ok}
\end{alltt}
The argument to this constructor does not actually have to be of 
the standard tuple type, but can be any \emph{tuple-like} type that acts
like the standard tuple type, in the sense of providing the same element
access interface. For example, \code{std::pair} is such a tuple-like
type.
For example:
%
\begin{alltt}
tuple<int, int> t3 = make_pair('a', 1); // \cccomment{ok}
\end{alltt}

\end{itemize}

\subsection{\code{make\_tuple}}

Tuples can also be constructed using the \code{make\_tuple} 
(cf. \code{make\_pair}) utility function templates. 
This makes the construction more convenient, saving the programmer 
from explicitly specifying the element types:
%
\begin{verbatim}
tuple<int, int, double> add_multiply_divide(int a, int b) {
  return make_tuple(a+b, a*b, double(a)/double(b));
}
\end{verbatim}
%
By default, the element types are plain non-reference types. 
E.g., the \code{make\_tuple} invocation below creates a tuple of type
\code{tuple<A, B>}:
\begin{verbatim}
void foo(const A& a, B& b) { 
  ...
  make_tuple(a, b);
  ...
}
\end{verbatim}
%
This default behavior can be changed with to utility functions \code{ref} 
and \code{cref}.
An argument wrapped with \code{ref} will cause the element type to be 
a reference to the argument type, and \code{cref} will similarly cause the element type to be a reference to the const argument type. 
For example:
%
\begin{alltt}
A a; B b; const A ca = a;
make_tuple(cref(a), b);      // \cccomment{constructs tuple<const A&, B>(a, b)}
make_tuple(ref(a), b);       // \cccomment{constructs tuple<A&, B>(a, b)}
make_tuple(ref(a), cref(b)); // \cccomment{constructs tuple<A&, const B&>(a, b)}
make_tuple(cref(ca));        // \cccomment{constructs tuple<const A&>(ca)}
make_tuple(ref(ca));         // \cccomment{constructs tuple<const A&>(ca)}
\end{alltt}

%
Array arguments to \code{make\_tuple} result in the corresponding tuple element
being a reference to a const array. 
This is to avoid the need to wrap arrays with \code{cref}, as arrays cannot
be copied as such anyway.
%
Note that \code{make\_tuple} cannot be made to accept references to function 
types without the \code{ref} wrapper, unless core language issue 295 
is resolved.

\subsection{Assignment}

The assignment operation is defined as element-wise assignment.
Consequently, two tuples are assignable as long as they are
element-wise assignable. For example:
%
\begin{alltt}
tuple<char, int, const char(&)[3]> t1('a', 1, "Hi");
tuple<int, float, std::string> t2;
t2 = t1; // \cccomment{ok}
\end{alltt}
%
Analogously to the converting copy constructor, it suffices that the
right-hand side of the assignment operator is a tuple-like object.


\subsection{The \code{tie} function templates}

The \code{tie} functions are a short-hand notation for creating tuples where
all element types are references. 
A \code{tie} call corresponds to an invocation of \code{make\_tuple} where 
all arguments have been wrapped with \code{ref}. 
For example, the \code{tie} and \code{make\_tuple} invocations below 
both return
the same type of tuple object, namely \verb|tuple<int&, char&, double&>|:
\begin{verbatim}
int i; char c; double d; 
tie(i, c, d);
make_tuple(ref(i), ref(c), ref(d)); 
\end{verbatim}
%
A tuple that contains non-const references as elements can be used to 
`unpack' another tuple into variables. 
For example:
%
\begin{verbatim}
int i; char c; double d; 
tie(i, c, d) = make_tuple(1, 'a', 5.5);
\end{verbatim}
After the assignment, \code{i == 1}, \code{c == 'a'} and \code{d == 5.5}.
A tuple unpacking operation like this is found, for example, in ML and Python. 
It is convenient when calling functions which return tuples.

%The tying mechanism works with std::pair templates as well:
%
%int i; char c;
%tie(i, c) = std::make_pair(1, 'a');

\subsubsection{Ignore}

The library provides an object called \code{ignore} which allows one 
to ignore elements in an assignment to a tuple. 
Any assignment to \code{ignore} is a no-operation.
For example:
\begin{verbatim}
char c;
tie(ignore, c) = make_tuple(1, 'a');
\end{verbatim}
After this assignment, \code{c == 'a'}.

\subsection{Number of elements}

The number of elements in a tuple type is accessible as a compile-time 
constant:
\begin{alltt}
tuple_size<tuple<int, int, int, int> >::value; // \cccomment{equals 4}
\end{alltt}

\subsection{Element type}

The type of the \code{N}th
element of a tuple type is accessed using 
the \code{tuple\_element} template:
\begin{alltt}
tuple_element<2, tuple<int, char, float, double> >::type // \cccomment{float}
\end{alltt}
%
Indexing is zero-based. 
The index must be an integral constant expression
and using an index that is out of bounds results in a compile time error.
%See section~\ref{nested_or_separate} for a discussion about
%why a separate traits class is used, instead of a nested class 
%within the tuple template.

\subsection{Element access}

Let \code{t} be a tuple object. 
The expression \code{get<N>(t)} returns a reference to the \code{N}th 
element of \code{t}, where \code{N} is an integral constant expression.
\begin{alltt}
tuple<int, float, char>(1, 3.14, 'a') t;
get<2>(t); // \cccomment{equals 'a'}
\end{alltt}
%
Indexing is zero-based. 
Using an index that is out of bounds results in a compilation error.
%Section~\ref{element_access} discusses alternatives for the
%syntax of element access.

\subsection{Relational operators}

Tuples implement the operators \code{==}, \code{!=}, \code{<}, \code{>}, 
\code{<=} and \code{>=} using the corresponding operators on elements.
This means that if any of these operators is defined between all elements of 
two tuples, the same operator is defined between the tuples as well. 

The \code{operator==} is defined as the logical AND of the element-wise 
equality comparisons.
The \code{operator!=} is defined as the logical OR of the
element-wise inequality comparisons.
The operators \code{<}, \code{>}, \code{<=} and \code{>=} each define a 
lexicographical ordering. % (see section~\ref{lexicographical_ordering}).
An attempt to compare two tuples of different lengths results in 
a compile-time error.
The comparison operators are ``short-circuited'': elementary comparisons 
start from the first elements and are performed only until the result is known.
Elements after that are not accessed.
For example: 
%But the operators must nevertheless be defined.

%Each comparison operator \emph{op} is defined solely using the same
%operator \emph{op} for the element-wise comparisons and makes no assumptions
%about the behavior of the other relational operators, or even
%whether they are defined or not.


\begin{alltt}
tuple<int, float, char> t(1, 2, 'a'); 
tuple<int, char, int> u(1, 1, 1000);
t < u; // \cccomment{ok, false}

tuple<int, int, int, int> x;
tuple<int, int, int> y; 
x < y; // \cccomment{error, different sizes}

tuple<int, int, complex<double>, int> x;
tuple<int, int, string, int> y; 
x < y; // \cccomment{error, no operator< between complex<double> and string}
\end{alltt}


\subsection{Input and output}

The library overloads the streaming operators \verb|<<| and \verb|>>| for 
tuples. 
Output is implemented by invoking \verb|operator<<| for each element,
and input similarly with invocations of \verb|operator>>|.
When writing a tuple to a stream, opening and closing 
characters are written around the body of the tuple.
Additionally, a delimiter character is written between each 
two consecutive elements.
Similarly, the opening, closing and delimiter characters are expected to be 
present when extracting
a tuple from an input stream.
The default delimiter between the elements is a space, and the default opening
and closing characters are the parentheses.
For example:
\begin{verbatim}
cout << make_tuple(1, 'a', "C++");
\end{verbatim}
outputs \code{(1 a C++)}.

The library defines three formatting manipulators for tuples, \code{tuple\_\-open}, 
\code{tuple\_close} and \code{tuple\_\-delimiter} to change, respectively, 
the opening, closing and delimiter characters for a particular stream.
For example:
\begin{verbatim}
cout << tuple_open('[') << tuple_close(']') 
     << tuple_delimiter(',') 
     << make_tuple(1, 'a', "C++");
\end{verbatim}
outputs the same tuple as: \code{[1,a,C++]}.

Note that in general it is not guaranteed that a tuple written to 
a stream can be extracted back to a tuple of the same type, since the 
streamed tuple representation may not be unambiguously parseable.
This is true, for instance, for tuples with \code{string} or C-style string 
element types.

\subsection{Performance}

Based on the experience with the Boost Tuple library, 
it is reasonable to expect an optimizing compiler to eliminate any extra cost 
of using tuples compared to using hand-written tuple-like classes.
Inlining and copy propagation are the optimizations required to attain 
this goal.

Concretely, accessing tuple members should be as efficient as accessing
a member variable of a class.
Further, constructing a tuple should have no other cost than the cost
of constructing the elements as separate objects.
The same should be true for assignment.
%To actually require this for a standard conforming implementation
%might be too drastic.


\part*{Text in the standard}

Text enclosed with brackets and typeset in sans serif is
a comment, not proposed standard text \textsf{[This is a comment]}.

\section{Annex B: Implementation quantities}

\textsf{[Add to the list of implementation quantities:]}

\smallskip 

--- Number of elements in one tuple type [10].

\section{Tuple library}

This clause describes the tuple library that provides a tuple type as 
the class template \code{tuple} that can be instantiated with any number
of arguments.
An implementation can set an upper limit for the number of arguments.
Each template argument specifies the type of an element in the \code{tuple}.
Consequently, tuples are heterogeneous, fixed-size collections of values. 

%Implementations are allowed to define the tuple template as an interface
%that inherits from some templated base class \code{T}, which stores
%the tuple elements.
%Such a template \code{T} is referred to as \emph{tuple implementation 
%template}.
%Further, implementations are allowed to define
%the functions that operate on tuple types 
%(comparison operators, \verb|>>| and \verb|<<|
%operators for input and output, element access functions) 
%overloaded for the tuple implementation template instead of the \code{tuple}
%template.

%, provided that instances of the tuple implementation template
%fulfill the requirements for \emph{tuple-like} types stated below.

%Element access, 
%The requirements for such a \emph{tuple implementation template} 
%are, that it must have the same observable behavior than refers to such 
%an implementation template, or to the tuple template if no 
%The implementation template mustIf \code{T} all the elements as provides all the functionality provided, and overload tuple operations (converting copy
%constructors, assignments, conversion operators, etc.) for the \code{T}
%templates, instead of \code{tuple} templates.

For certain tuple operations, the argument type does not have to a be tuple 
type.
Instead, it suffices that the argument type is \emph{tuple-like}.
The following subclauses describe the requirements for tuple
types and for types that are tuple-like.
All tuple types are tuple-like.

\subsubsection*{Valid Expressions for all types}


%\subsubsection*{Compile time expressions}


\hspace{\parindent} \code{is\_tuple<T>::value}

\smallskip

\req{Type:} \code{static const bool} (integral constant expression).\\
\req{Value:} \code{true} if \code{T} is, or derives from, an 
instantiation of the \code{tuple} template.
Users may not specialize this trait.
An implementation may define this trait for any tuple-like type.
%A user-defined specialization is allowed to change the value
%of this trait for types that derive from an instantiation of a tuple template.

\bigskip 

\code{is\_tuple\_like<T>::value}

\smallskip

\req{Type:} \code{static const bool} (integral constant expression).\\
\req{Value:} \code{true} if \code{T} is a tuple type or
an instance of \code{pair}.
Users may specialize this class template to indicate the conformance of a type
to the requirements for a tuple-like type.
Setting the value to \code{true} for a type that does not conform to all of 
the requirements for a tuple-like type causes undefined behavior.

\bigskip 

\code{tuple\_size<T>::value}

\smallskip

\req{Type:} \code{static const int} (integral constant expression).\\
\req{Value:} Number of elements in \code{T}. 
The number of elements in any non-tuple-like type is 1.
The number of elements in a tuple-like type must be nonnegative.

\bigskip

\code{tuple\_element<N, T>::type}

\nobreak

\smallskip 

\req{Requires:} 0 $\le$ \code{N} $<$ \code{tuple\_size<T>::value}\\ 
\req{Value:} The type of the \code{N}th element of \code{T}, where
indexing is zero-based.
If \code{T} is a non-tuple-like type and \code{N == 0}, the value is \code{T}.
A diagnostic must be produced for a value of \code{N} that is out of bounds.

\subsection{Tuple-like requirements}

A type \code{P} is tuple-like iff
\begin{itemize}
\item \code{is\_tuple\_like<P>::value == true}, and
\item \code{tuple\_size<P>::value} is a valid integral constant expression with a nonnegative value, and
\item \code{tuple\_element<N, P>::type} is a valid expression that designates a type whenever \code{N} is in bounds, and
\item \code{get<N>(p)}, where \code{p} is either of type \code{P} or \code{const P}, has the semantics defined in the \emph{Element access} subclause.
\end{itemize}

\subsubsection*{Element access}

\hspace{\parindent} \code{get<N>(p)}

\smallskip 

\req{Requires:} 0 $\le$ \code{N} $<$ \code{tuple\_size<P>::value}\\
\req{Return type:} \code{tuple\_element<N, P>::type\&}\\
\textsf{[Assuming core issue 106 is resolved to make a reference to a 
reference be just a reference instead of an error.
Otherwise, the return type must be defined as: \code{add\_reference<tuple\_element<N, P>::type>::type}.]}\\
\req{Returns:} A reference to the \code{N}th element of \code{p}, where
indexing is zero-based.

\bigskip

\code{get<N>(pc)}

\nobreak 

\smallskip 

\req{Requires:} 0 $\le$ \code{N} < \code{tuple\_size<P>::value}\\
\req{Return type:} \code{const tuple\_element<N, P>::type\&}\\
\textsf{[Assuming core issue 106 is resolved to make a reference to a 
reference be just a reference instead of an error.
Otherwise, the return type must be defined as: \code{add\_reference<const tuple\_element<N, P>::type>::type} (see~\cite{cit:type_traits_proposal:02}).]}\\
\req{Returns:} A reference to the \code{N}th element of \code{pc}, where indexing is
zero-based.\\
\req{Notes:} Constness is shallow. If \code{element\_type<N, P>::type} is some
reference type \code{X\&}, the return type is \code{X\&}, not \code{const X\&}.
However, if the element type is non-reference type \code{T}, the return
type is \code{const T\&}.

\smallskip  

\noindent \textsf{[ This is consistent with how constness is defined to work 
for member variables of reference type.]}

\smallskip  

\begin{sf}
\noindent 
[ There are alternative syntaces for element access.
One particularly appealing syntax is something like: \code{t[index<N>]}, or even
\verb|t[_1]|, \verb|t[_2]|, etc.
We decided not to propose that syntax, because \code{operator[]} cannot 
be defined as a free function, and would thus prevent adding tuple-likeness
into a type non-intrusively. ]
\end{sf}


\subsection{Requirements for tuple types}

\subsubsection*{Notation}

% How about volatile
\begin{tabular}{lp{9cm}}
\code{T}, \code{U} & are tuple types\\
\code{t}, \code{u} & objects of types \code{T} and \code{U}\\
\code{tc}, \code{uc} & objects of types \code{const T} and \code{const U}\\
\code{P} & a tuple-like type\\
\code{p}, \code{pc} & objects of types \code{P} and \code{const P}\\
\code{X$_i$} & the type of the $i$th element in \code{X}, where \code{X} is a tuple-like type\\
\code{x$_i$} & the $i$th element of \code{x}, where \code{x} is of a tuple-like type\\
For all $i$ in \code{X} & For all indices $i$ from 0 to \code{tuple\_size<X>::value - 1} for a tuple-like type \code{X}.
\end{tabular}

\smallskip 

\noindent The notation \code{T0, T1, ..., TN} 
stands for a comma separated list of
types which may contain any number of elements from 0 to $\code{N}+1$,
where $\code{N}+1 \le$ maximum number of allowed tuple elements. 
The notation \code{t0, t1, ..., tn} is an analogous list of objects.





\subsubsection*{Assignment}

\hspace{\parindent} \code{t = pc}
% is t = c needed

\smallskip

\req{Requires:} \code{tuple\_size<T>::value == tuple\_size<P>::value}. For all $i$ in \code{T}, 
\code{t$_i$ = pc$_i$} is a valid expression.\\
\req{Effects:} Performs \code{t$_i$ = pc$_i$} for all $i$ in \code{T}.\\
\req{Return type:} \code{T\&}\\
\req{Returns:} \code{t}


\subsubsection*{Equality and inequality comparisons}

\hspace{\parindent} \code{tc == uc}

\smallskip 

\req{Requires:} \code{tuple\_size<T>::value == tuple\_size<U>::value}. 
For all $i$ in \code{T},
\code{tc$_i$ == uc$_i$} is a valid expression returning a type that is
convertible to \code{bool}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} \code{true} iff \code{tc$_i$ == uc$_i$} for all $i$ in \code{T}.
For any two zero-length tuples \code{e} and \code{f}, \verb|e == f| returns \code{true}.\\
\req{Effects:} The elementary comparisons are performed in order from the zeroth index upwards. 
No comparisons or element accesses are performed after the first equality comparison that evaluates to \code{false}.

\bigskip 

\code{t != u}

\smallskip 

\req{Requires:} \code{T::size == U::size}. 
For all $i$ in \code{T}, 
\code{t$_i$ != u$_i$} is a valid expression returning a type that is 
convertible to \code{bool}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} \code{true} iff \code{t$_i$ != u$_i$} for some $i$.
For any two zero-length tuples \code{e} and \code{f}, \verb|e != f| returns \code{false}.\\
\req{Effects:} The elementary comparisons are performed in order from the zeroth index upwards. 
No comparisons or element accesses are performed after the first inequality comparison that evaluates to \code{true}.

\subsubsection*{\code{<}, \code{>}, \code{<=} and \code{>=} comparisons}

\hspace{\parindent} \code{t $\odot$ u}, where \code{$\odot$} is either \code{<} or \code{>}

\smallskip

\req{Requires:} \code{T::size == U::size}. For all $i$ in \code{T}, 
\code{t$_i$ $\odot$ u$_i$} and \code{u$_i$ $\odot$ t$_i$} are valid 
expressions whose result types are convertible to \code{bool}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} The result of a lexicographical comparison with \code{$\odot$} between \code{t} and \code{u}, defined equivalently to:

\code{(bool)(t$_0$ $\odot$ u$_0$) || !((bool)(u$_0$ $\odot$ t$_0$)) \&\&
                       t$_{\mathrm{tail}}$ $\odot$ u$_{\mathrm{tail}}$}, \\
where \code{r$_{\mathrm{tail}}$}
	for some tuple \code{r} is a tuple containing all but the first element of \code{r}. 
For any two zero-length tuples \code{e} and \code{f}, \code{e $\odot$ f} returns \code{false}.

\bigskip 

\code{t $\odot$ u}, where \code{$\odot$} is either \code{<=} or \code{>=}

\smallskip 

\req{Requires:} \code{T::size == U::size}. For all $i$ in \code{T}, 
\code{t$_i$ $\odot$ u$_i$} and \code{u$_i$ $\odot$ t$_i$} are valid 
expressions whose result types are convertible to \code{bool}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} The result of a lexicographical comparison with \code{$\odot$} between \code{t} and \code{u}, defined equivalently to:

\code{(bool)(t$_0$ $\odot$ u$_0$) \&\& (!((bool)(u$_0$ $\odot$ t$_0$)) ||
                       t$_{\mathrm{tail}}$ $\odot$ u$_{\mathrm{tail}}$)}, \\
where \code{r$_{\mathrm{tail}}$}
	for some tuple \code{r} is a tuple containing all but the first element of \code{r}. 
For any two zero-length tuples \code{e} and \code{f}, \code{e $\odot$ f} returns \code{true}.

\smallskip

\noindent
\req{Notes:} The above definitions for comparison operators 
do not impose the requirement that 
\code{t$_{\mathrm{tail}}$} (or \code{u$_{\mathrm{tail}}$}) must be 
constructed. It may be even impossible, as \code{t} (or \code{u}) is 
not required to be copy constructible.
Also, all comparison operators are short circuited to not perform element
accesses beyond what is required to determine the result of the comparison.

\medskip

\begin{sf}
\noindent [ The comparison operators (as well as streaming operators defined below),
are only defined for tuple types instead of tuple-like types.
This is because it is somewhat tricky to overload operators 
to accept any tuple-like type and not to create ambiguities.
A straightforward solution to provide comparison and streaming functionality
for tuple-like types would be to define fully generic function templates, 
with names like  \code{tuple\_print} and \code{tuple\_compare}, that 
implemented the same functionality as the comparison and streaming operators. ]
\end{sf}


\subsubsection*{Construction}

\hspace{\parindent} \verb|tuple<T0, T1, ..., TN>()|

\smallskip 

\req{Requires:} Each element type can be default constructed.\\
\req{Effects:} Default initializes each element.

\bigskip 

\verb|tuple<T0, T1, ... TN>(t0, t1, ..., tN)|

\nobreak 

\smallskip 

\req{Requires:} Each element type \code{Ti} is
copy constructible. 
%JAAKKO: Are all requirements of CopyConstructible required, probably not. 
%Also, maybe even copy constrcution is required only
%for some types that match directly. And what are references to copy constructible?
The type of each argument \code{ti} is convertible to \code{Ti}.\\
\req{Effects:} Copy initializes each element with the value of the 
corresponding parameter doing conversions as needed.

\bigskip 


\verb|tuple<T0, T1, ... TN>(pc)|

\smallskip 

\req{Requires:} \code{tuple\_size<P>::value == N+1}. 
%(JAAKKO, see above). 
For each $i$ in \code{P}, \code{P$_i$} is 
convertible to \code{Ti}.\\
\req{Effects:} Copy initializes each element $i$ with \code{pc$_i$}.

\smallskip

\noindent
\begin{sf}
[ There seem to exist (rare) conditions where the converting copy constructor
and element-wise construction conflict.
One example of this is if one is constructing a one-element tuple where 
the element type is another tuple type \code{T}.
If the parameter passed to the constructor is not of type \code{T}, but
rather a tuple type that is convertible to \code{T}, the conflict
arises.
It is possible to make this case fail, and provide another
constructor, distinguished with an extra dummy parameter.
Instead of 
\begin{verbatim}
tuple<tuple<A> >(tuple<B>())
\end{verbatim}
where \code{B} is convertible to \code{A}.
The programmer would then have to write something like:
\begin{verbatim}
tuple<tuple<A> >(tuple<B>(), ignore)
\end{verbatim}]
\end{sf}


\subsubsection*{Input and output}

In this section, a return type specified as \code{istream} 
or \code{ostream} is understood to mean an instance of 
\code{basic\_istream} or \code{basic\_ostream}, which is the type of
the returned stream object, or from which this type derives.

\bigskip 

\verb|os << t|, where \code{os} is an instance of \code{basic\_ostream}.
%should be defined for consts as well?

\smallskip 

\req{Requires:} For all $i$ in \code{T}, \verb|os << t|\code{$_i$} 
is a valid expression.\\
\req{Effects:} Inserts \code{t} into \code{os} as \code{$L$t$_0$$d$t$_1$$d$...$d$t$_nR$}, where $L$ is the opening, $d$ the delimiter and $R$ the closing
character, set by tuple formatting manipulators.
Each element \code{t$_i$} is output by invoking \verb|os << t|\code{$_i$}.
A zero-element tuple is output as $LR$ and a one-element tuple is output as \code{$L$t$_0R$}.
\\
\req{Return type:} \code{ostream\&}\\
\req{Returns:} \code{os}

\bigskip 

\verb|is >> t|, where \code{is} is an instance of \code{basic\_istream}.

\smallskip 

\req{Requires:} For all $i$ in \code{T}, \verb|is >> t|\code{$_i$} is a valid expression.\\
\req{Effects:} Extracts a tuple of the form \code{$L$t$_0$$d$t$_1$$d$...$d$t$_nR$},
where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple formatting manipulators.
Each element \code{t$_i$} is extracted by invoking \verb|is >> t|\code{$_i$}.
A zero-element tuple expects to extract $LR$ from the stream and 
one-element tuple expects to extract \code{$L$t$_0R$}.

If bad input is encountered, calls \code{is.set\_state(ios::failbit)} (which
may throw \code{ios::failure} (27.4.4.3).\\
\req{Return type:} \code{istream\&}\\
\req{Returns:} \code{is}\\
\req{Notes:} It is not guaranteed that a tuple written to 
a stream can be extracted back to a tuple of the same type.

\subsubsection*{Tuple formatting manipulators}

The library defines the following three stream manipulator functions.
The type designated \emph{tuple\_manip} is implementation-specified and may be
different for each function.

\smallskip 

\emph{tuple\_manip} \code{tuple\_open(char\_type c)}

\emph{tuple\_manip} \code{tuple\_close(char\_type c)}

\emph{tuple\_manip} \code{tuple\_delimiter(char\_type c)}

\smallskip 

\req{Returns:} Each of these functions returns an object \code{s} of unspecified 
type such that if \code{out} is an 
instance of \code{basic\_ostream<charT,traits>}, \code{in} is an instance of
\code{basic\_istream<charT,traits>} and \code{char\_type} equals \code{charT},
then the expression \verb|out << s| (respectively \verb|in >> s|) 
sets \code{c} to be
the opening, closing, or delimiter character (depending on the manipulator
function called) to be used when writing tuples into \code{out} (respectively
extracting tuples from \code{in}).\\
\req{Notes:} Implementations are not required to support these manipulators for 
streams with \code{sizeof(charT) > sizeof(long)}; \verb|out << s| and \verb|in >> s| are required to fail at compile time if 
\code{out} are \code{in} are such streams and the implementation does not
support tuple formatting manipulators for them.

\smallskip 

\noindent \textsf{[The constraint stated in the above \textbf{Notes} section allows an 
implementation where the delimiter characters are stored in
space allocated by \code{xalloc}, which allocates an array of \code{long}s.
A more general alternative is to store pointers to the delimiter 
characters in the \code{xalloc}-allocated array, and register a callback 
function (with \code{ios\_base::register\_callback}) for the stream to 
take care of deallocating the memory.
If this approach is taken, the delimiters could be chosen to be strings 
instead of single characters.
This might be worthwhile, such as to allow delimiters like \code{", "}.
]}


\subsubsection*{Utility functions for tuple construction}

The library provides the class template \code{any\_holder} that can hold
objects or references of any type. 
The observable behavior of \code{any\_holder} must be as if implemented:

\smallskip 

\begin{minipage}{10.5cm}
\begin{verbatim}
template <class T>
class any_holder {
  T data;
public:
  typedef T type;

  operator T() const { return data; }
  T unwrap() const { return data; }

  any_holder(const T& t) : data(t) {}
};
\end{verbatim}
\end{minipage}

\smallskip 

\noindent \textsf{[If core issue 106 is not resolved to make a reference to a 
reference be just a reference instead of an error,
the constructor parameter type must be defined as:
\code{typename add\_reference<typename add\_const<T>::type>::type}]
(see~\cite{cit:type_traits_proposal:02})}

\smallskip 

\noindent Reference types wrapped in \code{any\_holder} can be passed by copy, and
as const references, without affecting the constness of the wrapped object.
Two template functions, \code{ref} and \code{cref}, are provided to create
\code{any\_holder} objects.


\bigskip 

\verb|template <class T> inline any_holder<T&> ref(T& t);|

\smallskip 

\req{Returns:} \verb|any_holder<T&>(t)|.

\bigskip 

\verb|template <class T> inline any_holder<const T&> cref(const T& t);|

\smallskip 

\req{Requires:} \code{T} cannot be a function type.\\
\textsf{[This requirement may be unnecessary depending on the resolution of
core language issue 295]}\\
\req{Returns:} \verb|any_holder<const T&>(t)|.

\bigskip 

\begin{minipage}{10.5cm}
\begin{verbatim}
template<class V0, class V1, ..., class VN>
... make_tuple(const V0& v0, const V1& v1, ..., const VN& vn); 
\end{verbatim}
\end{minipage}

\smallskip

\req{Return type:} \code{tuple<T0, T1, ..., TN>}, where 
\begin{itemize}
\item if \code{Vi} is an array type, 
then \code{Ti} is a reference to \code{const Vi}.
\item if the cv-unqualified type \code{Vi} is 
\code{any\_holder<X>}, then \code{Ti} is \code{X}.
\item otherwise \code{Ti} is \code{Vi}, with 
any const qualifications removed.
\end{itemize}
\req{Example:} 

\smallskip 

\begin{minipage}{10.5cm}
\begin{verbatim}
int i; float j; 
make_tuple(1, "C++", ref(i), cref(j))
\end{verbatim}
\end{minipage}

\smallskip 

\noindent creates a tuple of type 

\smallskip 

\verb|tuple<int, const char (&) [4], int&, const float&>|

\smallskip 

\req{Notes:} The \code{make\_tuple} function template must be implemented
for each different number of arguments from 0 to the maximum number of allowed tuple elements.
To construct a tuple which contains a reference to a function,
 the 
function reference must be wrapped inside \code{ref}.

\bigskip 

\code{tie(t0, t1, ..., tn)}

\smallskip  

\req{Effects:} As if implemented:

\smallskip 

\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T0, class T1, ..., class TN>
tuple<T0&, T1&, ..., TN&> tie(T0& t0, T1& t1, ..., TN& tn) {
  return tuple<T0&, T1&, ..., TN&>(t0, t1, ..., tn); 
}
\end{verbatim}
\end{minipage}

\smallskip 

\noindent 
for each different number of arguments from 0 to the maximum number of 
allowed tuple elements.
% +

\bigskip 

\noindent The library provides the class \code{swallow\_assign}, as if implemented:
%

\smallskip 

\begin{minipage}{10.5cm}
\begin{verbatim}
struct swallow_assign {
  template <class T> 
  swallow_assign& operator=(const T&) { return *this; }
};
\end{verbatim}
\end{minipage}

\bigskip 

\noindent The library provides an object
\code{ignore} of type \code{swallow\_assign}.
It must be possible to use \code{ignore} in multiple translation units in 
a program.

\smallskip 

\req{Example:} \code{tie} functions allow one to create tuples that unpack 
tuple-like objects into variables. \code{ignore} can be used for elements that
are not needed:

\smallskip

\begin{minipage}{10.5cm}
\begin{alltt}
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// \cccomment{i == 42, s == "C++";}
\end{alltt}
\end{minipage}

\section{Pairs}

\textsf{[Wording to make pairs tuple-like]}

\smallskip 

Pairs are tuple-like types (see \textsf{[number of the section where tuple-like
is defined]}). The following subclauses define the semantics of the 
expressions pair types must support to comply to the tuple-like requirements. 

\subsubsection*{Notation}

\begin{tabular}{lp{10cm}}
\code{P} & is an instance of the \code{pair} template\\
\code{p}, \code{pc} & are objects of types \code{P} and \code{const P}
\end{tabular}

\bigskip 

\verb|is_tuple_like<P>::value|

\smallskip

\req{Type:} \code{static const bool} (integral constant expression).\\
\req{Value:} \code{true}.

\code{tuple\_size<P>::value}

\smallskip

\req{Type:} \code{static const int} (integral constant expression).\\
\req{Value:} 2

\bigskip

\code{tuple\_element<0, P>::type}

\smallskip 

\req{Values:} \code{P::first\_type}

\bigskip

\code{tuple\_element<1, P>::type}

\smallskip 

\req{Values:} \code{P::second\_type}

\bigskip

\code{get<0>(p)}

\smallskip 

\req{Return type:} \code{P::first\_type\&}\\
\req{Returns:} \code{p.first}

\bigskip

\code{get<1>(p)}

\smallskip 

\req{Return type:} \code{P::second\_type\&}\\
\req{Returns:} \code{p.second}

\bigskip

\code{get<0>(pc)}

\smallskip 

\req{Return type:} \code{const P::first\_type\&}\\
\req{Returns:} \code{pc.first}

\bigskip

\code{get<1>(pc)}

\smallskip 

\req{Return type:} \code{const P::second\_type\&}\\
\req{Returns:} \code{p.second}




\section{Acknowledgements}

The author is indebted to Jeremiah Willcock for his suggestions
and help in preparing this document.
%
The Boost Tuple Library, the basis of this proposal, has benefited from 
suggestions by many in the Boost community, including 
Gary Powell, Douglas Gregor, Jens Maurer, Jeremy Siek, William Kempf,
 Vesa Karvonen, John Max Skaller,
Ed Brey, Beman Dawes, David Abrahams and Hartmut Kaiser.


\bibliography{tuple_proposal}
\bibliographystyle{plain}


\end{document}


\section{Discussion about some design choices}

\subsection{About valid element types\label{about_valid_element_types}}

The proposed requirements state, that there are no restrictions on the types
of tuple elements, if the program contains no construction invocations 
for the tuple type.
For example, \code{void} and \code{int()()} are valid C++ types, but 
objects of these types can never be created. 
Hence, \code{tuple<void, int()()>} is a valid tuple type but obviously an
object of this type cannot be constructed.

A straightforward implementation, where the type of a template
parameter is a type of a member variable, does not fullfil the above
restriction. The types of the member variables are checked when the template 
is instantiated, and \code{void} and function types are rejected as member
types, even though an object is never constructed.

The way to cope with this issue is to transform each member through
a traits class, wrapping \code{void} and function types to something 
that can be a member variable, but cannot be constructed.

This means extra clutter in the code implementing tuple types, but
we find the feature important for uniformity. 
Otherwise tuple types would impose a restriction that does not exist
for the element types.

\subsubsection{Defining functions for the standard tuple type
vs. types that are tuple-like.}

In the proposal, tuple-like types do not support all the same operations
than tuple types.


\subsubsection{Element type as a nested or separate class template\label{nested_or_separate}}

\subsubsection{About element access\label{element_access}}

There are several alternative syntaces for element access. 
We list some of these choices with explanations:
%\begin{}
%\item \code{get<N>(t)} 


%t.get<N>();

%t.get(index<N>);
%t[index<N>];

%\end{itemize}
\subsection{About comparison operators\label{lexicographical_ordering}}

T
Mathematically wrong for product types, but practical.
(JAAKKO: stick somewhere justification, std::pair,
Haskell)

%\code{About tuples as built-in types\label{built-in_tuples}}
%
%Particularly, many languages consider the argument list to a function to
%be implicitly a tuple object (lanXXX, langYYY).
%This would be a remarkable improvement for generic programming in C++, 
%making truly generic wrapping, delegating, or forwarding functions possible.
%For example, the problem of not being able to inherit constructors would
%cease to exist, as one could define a constructor taking any tuple, and
%forward the tuple to the base class.

% Another important point EIFFEL, 
% Also, it is should be noted, that the programming language Eiffel does not
% allow varying number of generic parameters, except for tuple tuple types.
% The author is personally convinced that a built-in tuple type, with argument
% list of a function being implicitely a tuple object, and a mechanism to 
% (More on appendix)


%- Miksi assignment riittää paireista tupliin
%- Mikä on tuple\_size:n return type


The tuple type is impelemented as an interface template \code{tuple} that
can take up to $n$ (10 in the reference implementation) template arguments.
It is very tedious to overload functions for such a verbose type.
Consequently, the \code{tuple} interface class inherits from instantiations
of another type (\code{cons}) which represents the tuple element as a 
\emph{cons list}.
Comparison operators, streaming operators and element accessor functions all 
operate on the cons list representation.

We propose this representation be standardized as well, to give end programmers
a convenient way to overload functions for tuple types. 

\end{document}


\begin{sf}
\noindent [The tuple template has a large number of template parameters (10) 
or more, and it is thus tedious to overload functions for such a type.
In one possible implementation, the \code{tuple} interface class inherits 
from another template (say a cons list) which only has two template
parameters and represents tuples as a recursive instantiations of the
same template. 
The tuple operations can be defined much more succinctly for 
such recursively defined types.
See~\cite{cit:boost_tuple_library:01,jarvi:01:cuj_tuples} for an example.

However, this affects the way overload resolution works.
If some type \code{B} inherits from an instance of some template 
\code{A<T>}, a function with a fully generic interface is a better match
for \code{B} than a function overloaded for \code{A<T>}.
E.g.:
\begin{verbatim}
template <class T> void foo(const T& t); 
template <class T> void foo(const A<T>& t); 
class B : public A<int> {};
B b; 
foo(b); // \cccomment{calls the first, fully generic definition of foo
\end{verbatim}
overloading rules for templates make a fully generic template
function (\verb|template <class T> foo(const T& t)|) a better match.

Considering the subtlety of the way overload resolution works in this case, 
the explicit mention that the implementation is allowed to define the operators
with a function that is a worse match than a fully generic function,
is in order.
]
\end{sf}


\begin{verbatim}
cons(const typename remove_volatile<head_type>::type& h, 
     const tail_type& t);
\end{verbatim}
\requires{All elements are \concept{CopyConstructible}}.
\effects\ Initializes \code{head\_} with \code{h}
and \code{tail\_} with \code{t}.\\
\notes\ 
Unless \code{head\_type} is a non-const reference type, it is allowed 
to call the constructor with a temporary as the first argument.
When binding temporaries to references, the reference must
be to a non-volatile and const type (8.5.3 (5)). Thus \code{volatile}
is removed and \code{const} added. Reference types stay intact.


\begin{verbatim}
template <class H2, class T2> cons(const cons<H2, T2>& u);
\end{verbatim}

\effects\ Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.



\begin{verbatim}
cons& operator=(const cons& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}\\
\notes\ Default assignment operator is illformed if a class contains
member variables of reference types (12.8 (12)). 
Therefore an explicit definition is needed.

\begin{verbatim}
template <class T1, class T2> cons& operator=(const std::pair<T1, T2>& u);
\end{verbatim}
\requires\ \code{tuple\_size<cons> == 2} (ref????).\\
\effects\ As if implemented: 
\code{*this.head\_ = u.first; *this.tail\_.head\_ = u.second;}\\
\returns\ \code{*this}


\returns\ Reference to \code{head\_}.\\
\notes\ Constness is shallow. If \code{head\_type} is a non-const reference 
type, returns a non-const reference.






Osat:

- introduction to tuples

- text in standard

- reference implementation

- about the reference implementation


TODO:

- laita comparison-operaattoreihin conversion to bool before ! operator
-  change static cast to reintepret cast in or something in manipulators

- PREPROCESSOR_CONSTANT for max tuple length
- traits: (no limit)


