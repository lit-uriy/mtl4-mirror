\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}


%\usepackage[finnish]{babel}

\usepackage{fullpage}

\usepackage{url}
\usepackage{alltt}

\usepackage{ae}

\newcommand{\cccomment}[1]{\textrm{\textit{#1}}}

\newcommand{\effects}{\noindent \textbf{Effects:}}
\newcommand{\returns}{\noindent \textbf{Returns:}}
\newcommand{\returntype}{\noindent \textbf{Return type:}}
\newcommand{\requires}{\noindent \textbf{Requires:}}
\newcommand{\notes}{\noindent \textbf{Notes:}}
\newcommand{\values}{\noindent \textbf{Value:}}
\newcommand{\example}{\noindent \textbf{Example:}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\req}[1]{\noindent \textbf{#1}}

\newcommand{\concept}[1]{\textsf{#1}}

\author{Jaakko Järvi\\
Indiana University\\
Pervasive Technology Laboratories\\
Bloomington, IN\\
{\em jajarvi@cs.indiana.edu}}


\title{Proposal for adding tuple types into the standard library\\ \large{Programming Language C++}\\ \large{Document no: N1403=02-0061}}


\begin{document}
\maketitle

\markboth{Doc. no: N1403=02-0061}{Doc. no: N1403=02-0061}

\pagestyle{myheadings}


\section{Motivation}

Tuple types exist in several programming languages, such as Haskell, 
ML, Python and Eiffel, to name a few. 
Tuples are fixed-size heterogeneous 
containers. They are a general-purpose utility, 
adding to the expressiveness of the language. Some examples of 
common uses for tuple types are:
\begin{itemize}
\item Return types for functions that need to have more than one return type.
\item Grouping related types or objects (such as entries in parameter lists) 
into single entities.
\item Simultaneous assignment of multiple values.
\end{itemize}

This proposal describes tuple types for C++. 
The standard library provides the \code{pair}
template which is being used throughout the standard library, demonstrating 
the usefulness of tuple-like constructs.
The proposed tuple type is basically a generalization of the \code{pair} 
template from two to an arbitrary number of elements.
In addition to the features and functionality of pairs, 
the proposed tuple types:
\begin{itemize}
\item Support a wider range 
of element types (e.g. reference types).
\item Support input from and output to streams, customizable
with specific manipulators.
\item Provide a mechanism for `unpacking' tuple elements into separate variables.
\end{itemize}

\section{Impact on the standard}

All features described in this document can be implemented in a library,
without requiring any core language changes.
However, the implementation would benefit from a set of core language changes:
\begin{itemize}
\item Adding support for variable-length template argument lists.
\item Making a reference to a reference to some type \code{T} equal to 
a reference to \code{T} (core language issue 106).
\item Allowing default template arguments for function
templates (core language issue 226).
\item Ignoring cv-qualifiers that are added to function types (core language issue 295).
\item Adding support for templated typedefs.
\end{itemize}
%
%There are at least a few different approaches for implementing
%tuples underneath a common interface.

%For these reasons we do not mandate a particular template signature,
%
%suggest that a fixed implementation 
%be standardized, 
%but rather that the proposed text for the standard state the requirements for
%a tuple implementation 
%in the form of valid expressions and the semantics of those expressions.

The proposal is written in such a way that it leaves 
room for a built-in tuple type, or for a tuple template with special
support from the compiler, which we see as being worth considering.
Compared to built-in tuple types in other languages,
a library solution still falls short in some aspects.
For instance, in the programming language Python, 
the function argument list is implicitly a tuple.
This is a feature that cannot be added to C++ as a library, but
would be most useful.\footnote{Truly generic forwarding functions
that could take any number of parameters would be supported. For example, one constructor 
definition in a derived class could cover a large set of base class 
constructors with different arities and argument types.}
%Tuples as built-in types are discussed more in section~\ref{built-in_tuples}.

%In sum, this proposal defines the requirements for a standard tuple type.
%The requirements are stated so as to allow a library implementation with the
%current language, but also
%a future transition to 
%a more feature-rich built-in tuple type, or to a library implementation
%that can take advantage of new language features, such as variable length
%template argument lists or templated typedefs.

The concrete additions and changes to the standard are:
\begin{itemize}
\item A new section describing the requirements for the tuple template.
\item Backwards-compatible changes to \code{pair} to allow pairs to act
as tuples.
\item A utility class and two utility function templates to be used in passing
reference arguments through a pass-by-copy interface.
These templates have uses outside of tuples we suggest then to be 
included in section 20.2 (Utility components).
\end{itemize}

We propose a new new standard header \code{<tuple>}.
Operators for reading tuples from a stream and writing tuples to
a stream introduce a dependency to \code{<istream>} and \code{<ostream>},
so it is a quality-of-implementation issue to not include definitions
from these headers unnecessarily.


\section{Tuples in a nutshell}

The purpose of this section is to give an informal overview of the 
features that the tuple types provide.
The feature set is largely based on the Boost Tuple 
Library~\cite{cit:boost_tuple_library:01,jarvi:01:cuj_tuples}.

\subsection{Defining tuple types}

The \code{tuple} template can be instantiated with any number of arguments
from 0 to some predefined upper limit. In the Boost Tuple library, this limit is 10.
The argument types can be any valid C++ types.
For example:
\begin{verbatim}
typedef tuple<A, const B, volatile C, const volatile D> t1;
typedef tuple<int, int&, const int&, const volatile int&> t2;
typedef tuple<void, int()(int)> t3;
\end{verbatim}
Note that even types of which no objects can be created (cf. \code{void}, \code{int()(int)}), are valid tuple elements.
Naturally, an object of a tuple type with such an element type cannot 
be constructed. 
%(see section~\ref{about_valid_element_types}).

\subsection{Constructing tuples}

An $n$-element tuple has a default constructor, 
a constructor with $n$ parameters, 
a copy constructor and a \emph{converting copy constructor}.
By converting copy constructor we refer to a constructor that 
can construct a tuple from another tuple, as long as the type of each element
of the source tuple is convertible to the type of the corresponding 
element of the target tuple.
%
The types of the elements restrict which constructors can be used:
\begin{itemize}
\item If an $n$-element tuple is constructed with a constructor taking 
0 elements, all elements must be default constructible.
For example:
\begin{alltt}
tuple<int, float> a; // \cccomment{ok}
class no_default_constructor \{ no_default_constructor(); \};
tuple<int, no_default_constructor, float> b; // \cccomment{error}
tuple<int, int&> c; // \cccomment{error, no default construction for references}
\end{alltt}


\item If an $n$-element tuple is constructed with a constructor taking 
$n$ elements, all elements must be copy constructible and convertible
(default initializable) from the corresponding argument.
For example:
\begin{alltt}
tuple<int, const int, std::string>(1, 'a', "Hi")
tuple<int, std::string>(1, 2); // \cccomment{error}
\end{alltt}

\item If an $n$-element tuple is constructed with the converting copy 
constructor, each element type of the constructed tuple type must
be convertible from the corresponding element type
of the argument. 
\begin{alltt}
tuple<char, int, const char(&)[3]> t1('a', 1, "Hi");
tuple<int, float, std::string> t2 = t1; // \cccomment{ok}
\end{alltt}
%The argument to this constructor does not actually have to be of 
%the standard tuple type, but can be any \emph{tuple-like} type that acts
%like the standard tuple type, in the sense of providing the same element
%access interface. For example, 
Construction works from \code{std::pair} as well.
For example:
%
\begin{alltt}
tuple<int, int> t3 = make_pair('a', 1); // \cccomment{ok}
\end{alltt}

\end{itemize}

\subsection{\code{make\_tuple}}

Tuples can also be constructed using the \code{make\_tuple} 
(cf. \code{make\_pair}) utility function templates. 
This makes the construction more convenient, saving the programmer 
from explicitly specifying the element types:
%
\begin{verbatim}
tuple<int, int, double> add_multiply_divide(int a, int b) {
  return make_tuple(a+b, a*b, double(a)/double(b));
}
\end{verbatim}
%
By default, the element types are plain non-reference types. 
E.g., the \code{make\_tuple} invocation below creates a tuple of type
\code{tuple<A, B>}:
\begin{verbatim}
void foo(const A& a, B& b) { 
  ...
  make_tuple(a, b);
  ...
}
\end{verbatim}
%
This default behavior can be changed with to utility functions \code{ref} 
and \code{cref}.
An argument wrapped with \code{ref} will cause the element type to be 
a reference to the argument type, and \code{cref} will similarly cause the element type to be a reference to the const argument type. 
For example:
%
\begin{alltt}
A a; B b; const A ca = a;
make_tuple(cref(a), b);      // \cccomment{constructs tuple<const A&, B>(a, b)}
make_tuple(ref(a), b);       // \cccomment{constructs tuple<A&, B>(a, b)}
make_tuple(ref(a), cref(b)); // \cccomment{constructs tuple<A&, const B&>(a, b)}
make_tuple(cref(ca));        // \cccomment{constructs tuple<const A&>(ca)}
make_tuple(ref(ca));         // \cccomment{constructs tuple<const A&>(ca)}
\end{alltt}

%
%Array arguments to \code{make\_tuple} result in the corresponding tuple element
%being a reference to a const array. 
%This is to avoid the need to wrap arrays with \code{cref}, as arrays cannot
%be copied as such anyway.
%
Note that \code{make\_tuple} cannot be made to accept references to function 
types without the \code{ref} wrapper, unless core language issue 295 
is resolved.

\subsection{Assignment}

The assignment operation is defined as element-wise assignment.
Consequently, two tuples are assignable as long as they are
element-wise assignable. For example:
%
\begin{alltt}
tuple<char, int, const char(&)[3]> t1('a', 1, "Hi");
tuple<int, float, std::string> t2;
t2 = t1; // \cccomment{ok}
\end{alltt}
%
Analogously to the converting copy constructor, assignment 
is defined from pairs as well.


\subsection{The \code{tie} function templates}

The \code{tie} functions are a short-hand notation for creating tuples where
all element types are references. 
A \code{tie} call corresponds to an invocation of \code{make\_tuple} where 
all arguments have been wrapped with \code{ref}. 
For example, the \code{tie} and \code{make\_tuple} invocations below 
both return
the same type of tuple object, namely \verb|tuple<int&, char&, double&>|:
\begin{verbatim}
int i; char c; double d; 
tie(i, c, d);
make_tuple(ref(i), ref(c), ref(d)); 
\end{verbatim}
%
A tuple that contains non-const references as elements can be used to 
`unpack' another tuple into variables. 
For example:
%
\begin{verbatim}
int i; char c; double d; 
tie(i, c, d) = make_tuple(1, 'a', 5.5);
\end{verbatim}
After the assignment, \code{i == 1}, \code{c == 'a'} and \code{d == 5.5}.
A tuple unpacking operation like this is found, for example, in ML and Python. 
It is convenient when calling functions which return tuples.

%The tying mechanism works with std::pair templates as well:
%
%int i; char c;
%tie(i, c) = std::make_pair(1, 'a');

\subsubsection{Ignore}

The library provides an object called \code{ignore} which allows one 
to ignore elements in an assignment to a tuple. 
Any assignment to \code{ignore} is a no-operation.
For example:
\begin{verbatim}
char c;
tie(ignore, c) = make_tuple(1, 'a');
\end{verbatim}
After this assignment, \code{c == 'a'}.

\subsection{Number of elements}

The number of elements in a tuple type is accessible as a compile-time 
constant:
\begin{alltt}
tuple_size<tuple<int, int, int, int> >::value; // \cccomment{equals 4}
\end{alltt}

\subsection{Element type}

The type of the \code{N}th
element of a tuple type is accessed using 
the \code{tuple\_element} template:
\begin{alltt}
tuple_element<2, tuple<int, char, float, double> >::type // \cccomment{float}
\end{alltt}
%
Indexing is zero-based. 
The index must be an integral constant expression
and using an index that is out of bounds results in a compile time error.
%See section~\ref{nested_or_separate} for a discussion about
%why a separate traits class is used, instead of a nested class 
%within the tuple template.

\subsection{Element access}

Let \code{t} be a tuple object. 
The expression \code{get<N>(t)} returns a reference to the \code{N}th 
element of \code{t}, where \code{N} is an integral constant expression.
\begin{alltt}
tuple<int, float, char>(1, 3.14, 'a') t;
get<2>(t); // \cccomment{equals 'a'}
\end{alltt}
%
Indexing is zero-based. 
Using an index that is out of bounds results in a compilation error.
%Section~\ref{element_access} discusses alternatives for the
%syntax of element access.

\subsection{Relational operators}

Tuples implement the operators \code{==}, \code{!=}, \code{<}, \code{>}, 
\code{<=} and \code{>=} using the corresponding operators on elements.
This means that if any of these operators is defined between all elements of 
two tuples, the same operator is defined between the tuples as well. 

The \code{operator==} is defined as the logical AND of the element-wise 
equality comparisons.
The \code{operator!=} is defined as the logical OR of the
element-wise inequality comparisons.
The operators \code{<}, \code{>}, \code{<=} and \code{>=} each define a 
lexicographical ordering. % (see section~\ref{lexicographical_ordering}).
An attempt to compare two tuples of different lengths results in 
a compile-time error.
The comparison operators are ``short-circuited'': elementary comparisons 
start from the first elements and are performed only until the result is known.
Elements after that are not accessed.
For example: 
%But the operators must nevertheless be defined.

%Each comparison operator \emph{op} is defined solely using the same
%operator \emph{op} for the element-wise comparisons and makes no assumptions
%about the behavior of the other relational operators, or even
%whether they are defined or not.


\begin{alltt}
tuple<int, float, char> t(1, 2, 'a'); 
tuple<int, char, int> u(1, 1, 1000);
t < u; // \cccomment{ok, false}

tuple<int, int, int, int> x;
tuple<int, int, int> y; 
x < y; // \cccomment{error, different sizes}

tuple<int, int, complex<double>, int> x;
tuple<int, int, string, int> y; 
x < y; // \cccomment{error, no operator< between complex<double> and string}
\end{alltt}


\subsection{Input and output}

The library overloads the streaming operators \verb|<<| and \verb|>>| for 
tuples. 
Output is implemented by invoking \verb|operator<<| for each element,
and input similarly with invocations of \verb|operator>>|.
When writing a tuple to a stream, opening and closing 
characters are written around the body of the tuple.
Additionally, a delimiter character is written between each 
two consecutive elements.
Similarly, the opening, closing and delimiter characters are expected to be 
present when extracting
a tuple from an input stream.
The default delimiter between the elements is a space, and the default opening
and closing characters are the parentheses.
For example:
\begin{verbatim}
cout << make_tuple(1, 'a', "C++");
\end{verbatim}
outputs \code{(1 a C++)}.

The library defines three formatting manipulators for tuples, \code{tuple\_\-open}, 
\code{tuple\_close} and \code{tuple\_\-delimiter} to change, respectively, 
the opening, closing and delimiter characters for a particular stream.
For example:
\begin{verbatim}
cout << tuple_open('[') << tuple_close(']') 
     << tuple_delimiter(',') 
     << make_tuple(1, 'a', "C++");
\end{verbatim}
outputs the same tuple as: \code{[1,a,C++]}.

Note that in general it is not guaranteed that a tuple written to 
a stream can be extracted back to a tuple of the same type, since the 
streamed tuple representation may not be unambiguously parseable.
This is true, for instance, for tuples with \code{string} or C-style string 
element types.

\subsection{Performance}

Based on the experience with the Boost Tuple library, 
it is reasonable to expect an optimizing compiler to eliminate any extra cost 
of using tuples compared to using hand-written tuple-like classes.
Inlining and copy propagation are the optimizations required to attain 
this goal.

Concretely, accessing tuple members should be as efficient as accessing
a member variable of a class.
Further, constructing a tuple should have no other cost than the cost
of constructing the elements as separate objects.
The same should be true for assignment.
%To actually require this for a standard conforming implementation
%might be too drastic.


\part*{Text in the standard}

Text enclosed with brackets and typeset in sans serif is
a comment, not proposed standard text \textsf{[This is a comment]}.

\section{Annex B: Implementation quantities}

\textsf{[Add to the list of implementation quantities (which specifies the
recommended minima for implementation quantities).]}

\medskip 

--- Number of elements in one tuple type [10].

\medskip


\section{Tuple library}

This clause describes the tuple library that provides a tuple type as 
the class template \code{tuple} that can be instantiated with any number
of arguments.
An implementation can set an upper limit for the number of arguments.
The minimum value for this implementation
quantity is defined in Annex B.
Each template argument specifies the type of an element in the \code{tuple}.
Consequently, tuples are heterogeneous, fixed-size collections of values. 

%Implementations are allowed to define the tuple template as an interface
%that inherits from some templated base class \code{T}, which stores
%the tuple elements.
%Such a template \code{T} is referred to as \emph{tuple implementation 
%template}.
%Further, implementations are allowed to define
%the functions that operate on tuple types 
%(comparison operators, \verb|>>| and \verb|<<|
%operators for input and output, element access functions) 
%overloaded for the tuple implementation template instead of the \code{tuple}
%template.

%, provided that instances of the tuple implementation template
%fulfill the requirements for \emph{tuple-like} types stated below.

%Element access, 
%The requirements for such a \emph{tuple implementation template} 
%are, that it must have the same observable behavior than refers to such 
%an implementation template, or to the tuple template if no 
%The implementation template mustIf \code{T} all the elements as provides all the functionality provided, and overload tuple operations (converting copy
%constructors, assignments, conversion operators, etc.) for the \code{T}
%templates, instead of \code{tuple} templates.


\subsubsection*{Header \code{<tuple>} synopsis}

\noindent\hspace{\parindent}  \begin{minipage}{10.5cm} \begin{alltt}
template <class T1 = \textrm{\emph{implementation-defined}}, 
          class T2 = \textrm{\emph{implementation-defined}}, 
          ..., 
          class TM = \textrm{\emph{implementation-defined}}> class tuple;

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator==(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator!=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator<(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator<=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator>(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator>=(const tuple<T1, T2, ..., TM>&, const tuple<U1, U2, ..., UM>&);

template <class T> class tuple_size;

template <int I, class T> class tuple_element;

template <int I, class T1, class T2, ..., class TN> 
\textrm{\emph{RI}} get(tuple<T1, T2, ..., TN>&);

template <int I, class T1, class T2, ..., class TN> 
\textrm{\emph{PI}} get(const tuple<T1, T2, ..., TN>&);

template<class T1, class T2, ..., class TN>
tuple<\textrm{\emph{V1}}, \textrm{\emph{V2}}, ..., \textrm{\emph{VN}}> 
make_tuple(const T1&, const T2& , ..., const TN&); 

template<class T1, class T2, ..., class TN>
tuple<T1&, T2&, ..., TN&> tie(T1&, T2& , ..., TN&); 

template<class CharType, class CharTrait, class T1, class T2, ..., class TN>
basic_ostream<CharType, CharTrait>& 
operator<<(basic_ostream<CharType, CharTrait>&, const tuple<T1, T2, ..., TN>&);

template<class CharType, class CharTrait, class T1, class T2, ..., class TN>
basic_istream<CharType, CharTrait>& 
operator>>(basic_istream<CharType, CharTrait>&, tuple<T1, T2, ..., TN>&);

\textrm{\emph{tuple_manip1}} tuple_open(\textrm{\emph{char\_type}} c);
\textrm{\emph{tuple_manip2}} tuple_close(\textrm{\emph{char\_type}} c);
\textrm{\emph{tuple_manip3}} tuple_delimiter(\textrm{\emph{char\_type}} c);
\end{alltt}
\end{minipage}

\medskip

%If \code{Ti} is a reference type then \code{Pi} is \code{Ti}, otherwise
%\code{Pi} is \code{const Ti\&}.


\subsubsection*{Class template \code{tuple}}

\code{M} is used to denote the implementation-defined number of template type parameters to the tuple class template, and 
\code{N} is used to denote the number of template arguments specified in an instantiation.

\medskip 

\noindent 
[\emph{Example:} Given the instantiation \verb|tuple<int, float, char>|, \code{N} is 3.
--\emph{end example}]
%\begin{sf}
%[
%An implementation can statically determine \verb|N| with template meta-programming. 
%]
%\end{sf}

\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{alltt}
template <class T1 = \textrm{\emph{implementation-defined}}, 
          class T2 = \textrm{\emph{implementation-defined}}, 
          ..., 
          class TM = \textrm{\emph{implementation-defined}}> class tuple \{
public:
  tuple();
  explicit tuple(P1, P2, ..., PN); // iff N > 0

  tuple(const tuple&);

  template <class U1, class U2, ..., class UN> 
  tuple(const tuple<U1, U2, ..., UN>&);

  template <class U1, class U2>
  tuple(const pair<U1, U2>&);

  tuple& operator=(const tuple&);

  template <class U1, class U2, ..., class UN> 
  tuple& operator=(const tuple<U1, U2, ..., UN>&);

  template <class U1, class U2>
  tuple& operator=(const pair<U1, U2>&);
\};
\end{alltt}
\end{minipage}

\medskip



\subsubsection*{Construction}

\noindent \hspace{\parindent} \verb|tuple();|

\medskip 
\req{Requires:} Each tuple element type \code{Ti} can be default constructed.\\
\req{Effects:} Default initializes each element.

\bigskip 

\noindent \hspace{\parindent} \verb|tuple(P1, P2, ..., PN);|

\medskip 

\noindent Where, if \code{Ti} is a reference type then \code{Pi} is \code{Ti}, otherwise
\code{Pi} is \code{const Ti\&}.\\
\req{Requires:} Each tuple element type \code{Ti} is
copy constructible.\\ 
%JAAKKO: Are all requirements of CopyConstructible required, probably not. 
%Also, maybe even copy constrcution is required only
%for some types that match directly. And what are references to copy constructible?
%The type of each argument \code{ti} is convertible to \code{Ti}.\\
\req{Effects:} Copy initializes each element with the value of the 
corresponding parameter.
% doing conversions as needed.

\bigskip 

\noindent \hspace{\parindent} \verb|tuple(const tuple& u);|

\medskip

\req{Requires:} all types \code{Ti} shall be copy constructible.\\
\req{Effects:} Copy constructs each element of \code{*this} with the 
corresponding element of \code{u}.

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template <class U1, class U2, ..., class UN> 
tuple(const tuple<U1, U2, ..., UN>& u);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} Each type \code{Ti} shall be constructible from the corresponding type \code{Ui}.\\
\req{Effects:} Constructs each element of \code{*this} with the 
corresponding element of \code{u}.

\medskip 

\noindent \textsf[ In an implementation where one template definition serves for
many different values for \code{N}, enable\_if can be used to 
make the converting constructor and assignment operator exist only in the cases where
the source and target have the same number of elements.
Another way of achieving this is adding an extra integral template parameter
which defaults to \code{N} (more precisely, a metafunction that computes \code{N}), and then defining the
converting copy constructor and assignment only for tuples where the extra parameter in 
the source is \code{N}.]

\bigskip 


\noindent\hspace{\parindent}
\verb|template <class U1, class U2> tuple(const pair<U1, U2>& u);|

\medskip 

\req{Requires:} \code{T1} shall be constructible from \code{U1},
\code{T2} shall be constructible from \code{U2}.
\code{N == 2}.\\
\req{Effects:} Constructs the first element with \code{u.first} and the
second element with \code{u.second}.

\bigskip

\noindent\hspace{\parindent}
\verb|tuple& operator=(const tuple& u);|

\medskip

\req{Requires:} All types \code{Ti} are assignable.\\
\req{Effects:} Assigns each element of \code{u} to the corresponding 
element of \code{*this}.\\
\req{Returns:} \code{*this}

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template <class U1, class U2, ..., class UN> 
tuple& operator=(const tuple<U1, U2, ..., UN>& u);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} Each type \code{Ti} shall be assignable from the 
corresponding type \code{Ui}.\\
\req{Effects:} Assigns each element of \code{u} to the corresponding
 element of \code{*this}.\\
\req{Returns:} \code{*this}

\bigskip 


\noindent\hspace{\parindent}
\verb|template <class U1, class U2> tuple& operator=(const pair<U1, U2>& u);|

\medskip 

\req{Requires:} \code{T1} shall be assignable from \code{U1},
\code{T2} shall be assignable from \code{U2}.
\code{N == 2}.\\
\req{Effects:} Assigns \code{u.first} to the first element of \code{*this}
and \code{u.second} to the second element of \code{*this}.\\
\req{Returns:} \code{*this}

\medskip



\noindent
\begin{sf}
[ There seem to exist (rare) conditions where the converting copy constructor
is a better match than the element-wise construction, even though the user
might intend differently.
An example of this is if one is constructing a one-element tuple where 
the element type is another tuple type \code{T} and if 
the parameter passed to the constructor is not of type \code{T}, but
rather a tuple type that is convertible to \code{T}.
The effect of the converting copy construction is most likely the same
as the effect of the element-wise construction would have been.
However, it it possible to compare the 'nesting depths' of the source and
target tuples and decide to select the element-wise constructor if the 
source nesting depth is smaller than the target nesting-depth. 
This can be accomplished using an enable\_if template or other tools for
constrained templates.
%It is possible to make this case fail, and provide another
%constructor, distinguished with an extra dummy parameter.
%Instead of 
%\begin{verbatim}
%tuple<tuple<A> >(tuple<B>())
%\end{verbatim}
%where \code{B} is convertible to \code{A}.
%The programmer would then have to write something like:
%\begin{verbatim}
%tuple<tuple<A> >(tuple<B>(), ignore)
%\end{verbatim}
]
\end{sf}


\subsubsection*{Tuple creation functions}

\noindent\hspace{\parindent} 
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TN>
tuple<V1, V2, ..., VN> 
make_tuple(const T1& t1, const T2& t2, ..., const TN& tn); 
\end{verbatim}
\end{minipage}

\medskip

\noindent where \code{Vi} is \code{X\&}, if the cv-unqualified type \code{Ti} is \code{reference\_wrapper<X>}, otherwise \code{Vi} is \code{Ti}.

\medskip 

\req{Returns:} \code{tuple<V1, V2, ..., VN>(t1, t2, ..., tn)}.\\
\req{Notes:} The \code{make\_tuple} function template must be implemented
for each different number of arguments from 0 to the maximum number of allowed tuple elements.
%To construct a tuple which contains a reference to a function,
% the 
%function reference must be wrapped inside \code{ref}.

\medskip 

\noindent 
[\emph{Example:}

\medskip 

\noindent\hspace{\parindent}
\begin{minipage}{10.5cm}
\begin{verbatim}
int i; float j; 
make_tuple(1, ref(i), cref(j))
\end{verbatim}
\end{minipage}

\medskip 

\noindent creates a tuple of type 

\medskip 

\noindent\hspace{\parindent}  
\verb|tuple<int, int&, const float&>|

\medskip 

\noindent --\emph{end example}]

\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TN>
tuple<T1&, T2&, ..., TN> tie(T1& t1, T2& t2, ..., TN& tn); 
\end{verbatim}
\end{minipage}

\medskip  

\req{Returns:} \verb|tuple<T1&, T2&, ..., TN&>(t1, t2, ..., tn)|\\
\req{Notes:} The \code{tie} function template must be implemented
for each different number of arguments from 0 to the maximum number of allowed tuple elements.

\medskip

\noindent 
[\emph{Example:}

\medskip 

\noindent \code{tie} functions allow one to create tuples that unpack 
tuples into variables. \code{ignore} can be used for elements that
are not needed:
%add reference to ignore

\medskip

\noindent\hspace{\parindent} 
\begin{minipage}{10.5cm}
\begin{alltt}
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// \cccomment{i == 42, s == "C++";}
\end{alltt}
\end{minipage}

\medskip 

\noindent --\emph{end example}]

\subsubsection*{Valid expressions for tuple types}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
tuple_size<T>::value
\end{verbatim}
\end{minipage}

\medskip

\req{Requires:} \code{T} is an instantiation of class template tuple. \\
\req{Type:} integral constant expression.\\
\req{Value:} Number of elements in \code{T}. 


\bigskip

\noindent\hspace{\parindent}  
\code{tuple\_element<I, T>::type}

\medskip 

\req{Requires:} 0 $\le$ \code{I} $<$ \code{tuple\_size<T>::value}.
The program is ill-formed if \code{I} is out of bounds. \\ 
\req{Value:} The type of the \code{I}th element of \code{T}, where
indexing is zero-based.


\subsubsection*{Element access}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template <int I, class T1, class T2, ..., class TN> 
RI get(tuple<T1, T2, ..., TN>& t);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} 0 $\le$ \code{I} $<$ \code{N}.
The program is ill-formed if \code{I} is out of bounds.\\
\req{Return type:} \code{RI}. If \code{TI} is a reference type, then \code{RI}
is \code{TI}, otherwise \code{RI} is \code{TI\&}.\\
\req{Returns:} A reference to the \code{I}th element of \code{t}, where
indexing is zero-based.

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template <int I, class T1, class T2, ..., class TN> 
PI get(const tuple<T1, T2, ..., TN>& t);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} 0 $\le$ \code{I} $<$ \code{N}.
The program is ill-formed if \code{I} is out of bounds.\\
\req{Return type:} \code{PI}. If \code{TI} is a reference type, then \code{PI}
is \code{TI}, otherwise \code{PI} is \code{const TI\&}.\\
\req{Returns:} A const reference to the \code{I}th element of \code{t}, where
indexing is zero-based.

\medskip  

\noindent \textsf{[ Constness is shallow. If \code{TI} is some
reference type \code{X\&}, the return type is \code{X\&}, not \code{const X\&}.
However, if the element type is non-reference type \code{T}, the return
type is \code{const T\&}.
This is consistent with how constness is defined to work 
for member variables of reference type.]}

\medskip  

\begin{sf}
\noindent 
[ Implementing \code{get} as a member function of tuple, would require using
the \code{template} keyword in invocations where the type of the tuple object 
is dependent on a template parameter. For example: \verb|t.template get<1>();|
]
\end{sf}

%\begin{sf}
%\noindent 
%[ There are alternative syntaces for element access.
%One particularly appealing syntax is something like: \code{t[index<N>]}, or even
%\verb|t[_1]|, \verb|t[_2]|, etc.
%We decided not to propose that syntax, because \code{operator[]} cannot 
%be defined as a free function, and would thus prevent adding tuple-likeness
%into a type non-intrusively. ]
%\end{sf}


%\subsection{Requirements for tuple types}
%
%\subsubsection*{Notation}
%
%% How about volatile
%\begin{tabular}{lp{9cm}}
%\code{T}, \code{U} & are tuple types\\
%\code{t}, \code{u} & objects of types \code{T} and \code{U}\\
%\code{tc}, \code{uc} & objects of types \code{const T} and \code{const U}\\
%\code{P} & a tuple-like type\\
%\code{p}, \code{pc} & objects of types \code{P} and \code{const P}\\
%\code{X$_i$} & the type of the $i$th element in \code{X}, where \code{X} is a tuple-like type\\
%\code{x$_i$} & the $i$th element of \code{x}, where \code{x} is of a tuple-like type\\
%For all $i$ in \code{X} & For all indices $i$ from 0 to \code{tuple\_size<X>::value - 1} for a tuple-like type \code{X}.
%\end{tabular}

%\medskip 
%
%\noindent The notation \code{T0, T1, ..., TN} 
%stands for a comma separated list of
%types which may contain any number of elements from 0 to $\code{N}+1$,
%where $\code{N}+1 \le$ maximum number of allowed tuple elements. 
%The notation \code{t0, t1, ..., tn} is an analogous list of objects.


\subsubsection*{Equality and inequality comparisons}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator==(const tuple<T1, T2, ..., TM>& t, 
                const tuple<U1, U2, ..., UM>& u);
\end{verbatim}
\end{minipage}


\medskip 

\req{Requires:} \code{tuple\_size<tuple<T1, T2, ..., TM> >::value == tuple\_size<tuple<U1, U2, ..., UM> >::value == N}. 
For all \code{i}, where \code{0 <= i < N},
\code{get<i>(t) == get<i>(u)} is a valid expression returning a type that is
convertible to \code{bool}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} \code{true} iff \code{get<i>(t) == get<i>(u)} for all \code{i}.
For any two zero-length tuples \code{e} and \code{f}, \verb|e == f| returns \code{true}.\\
\req{Effects:} The elementary comparisons are performed in order from the zeroth index upwards. 
No comparisons or element accesses are performed after the first equality comparison that evaluates to \code{false}.

\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TM, class U1, class U2, ..., class UM>
bool operator!=(const tuple<T1, T2, ..., TM>& t, 
                const tuple<U1, U2, ..., UM>& u);
\end{verbatim}
\end{minipage}


\medskip 

\req{Requires:} \code{tuple\_size<tuple<T1, T2, ..., TM> >::value == tuple\_size<tuple<U1, U2, ..., UM> >::value == N}. 
For all \code{i}, where \code{0 <= i < N},
\code{get<i>(t) != get<i>(u)} is a valid expression returning a type that is
convertible to \code{bool}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} \code{true} iff \code{get<i>(t) != get<i>(u)} for any \code{i}.
For any two zero-length tuples \code{e} and \code{f}, \verb|e != f| returns \code{false}.\\
\req{Effects:} The elementary comparisons are performed in order from the zeroth index upwards. 
No comparisons or element accesses are performed after the first inequality comparison that evaluates to \code{true}.

\bigskip 

\subsubsection*{\code{<}, \code{>} comparisons}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TN, class U1, class U2, ..., class UN>
bool operator<(const tuple<T1, T2, ..., TN>&, const tuple<U1, U2, ..., UN>&);

template<class T1, class T2, ..., class TN, class U1, class U2, ..., class UN>
bool operator>(const tuple<T1, T2, ..., TN>&, const tuple<U1, U2, ..., UN>&);
\end{verbatim}
\end{minipage}

\medskip


\req{Requires:} \code{tuple\_size<tuple<T1, T2, ..., TM> >::value == tuple\_size<tuple<U1, U2, ..., UM> >::value == N}. 
For all \code{i}, where \code{0 <= i < N},
\code{get<i>(t) \code{$\odot$} get<i>(u)} is a valid expression returning a type that is
convertible to \code{bool}, where \code{$\odot$} is either \code{<} or \code{>}.\\
\req{Return type:} \code{bool}\\
\req{Returns:} The result of a lexicographical comparison with \code{$\odot$} between \code{t} and \code{u}, defined equivalently to:

\code{(bool)(get<0>(t) $\odot$ get<0>(u)) || !((bool)(get<0>(u) $\odot$ get<0>(t)) \&\&
 t$_{\mathrm{tail}}$ $\odot$ u$_{\mathrm{tail}}$}, \\
where \code{r$_{\mathrm{tail}}$}
	for some tuple \code{r} is a tuple containing all but the first element of \code{r}. 
For any two zero-length tuples \code{e} and \code{f}, \code{e $\odot$ f} returns \code{false}.


\bigskip 

\subsubsection*{\code{<=} and \code{>=} comparisons}

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2, ..., class TN, class U1, class U2, ..., class UN>
bool operator<=(const tuple<T1, T2, ..., TN>&, const tuple<U1, U2, ..., UN>&);

template<class T1, class T2, ..., class TN, class U1, class U2, ..., class UN>
bool operator>=(const tuple<T1, T2, ..., TN>&, const tuple<U1, U2, ..., UN>&);
\end{verbatim}
\end{minipage}

\medskip


\req{Requires:} \code{tuple\_size<tuple<T1, T2, ..., TM> >::value == tuple\_size<tuple<U1, U2, ..., UM> >::value == N}. 
For all \code{i}, where \code{0 <= i < N},
\code{get<i>(t) \code{$\odot$} get<i>(u)} is a valid expression returning a type that is
convertible to \code{bool}, where \code{$\odot$} is either \code{<=} or \code{>=}.\\
\req{Returns:} The result of a lexicographical comparison with \code{$\odot$} between \code{t} and \code{u}, defined equivalently to:

\code{(bool)(get<0>(t) $\odot$ get<0>(u)) \&\& (!((bool)(get<0>(u) $\odot$ get<0>(t)) ||
                       t$_{\mathrm{tail}}$ $\odot$ u$_{\mathrm{tail}}$)}, \\
where \code{r$_{\mathrm{tail}}$}
	for some tuple \code{r} is a tuple containing all but the first element of \code{r}. 
For any two zero-length tuples \code{e} and \code{f}, \code{e $\odot$ f} returns \code{true}.

\medskip

\noindent
\req{Notes:} The above definitions for comparison operators 
do not impose the requirement that 
\code{t$_{\mathrm{tail}}$} (or \code{u$_{\mathrm{tail}}$}) must be 
constructed. It may be even impossible, as \code{t} (or \code{u}) is 
not required to be copy constructible.
Also, all comparison operators are short circuited to not perform element
accesses beyond what is required to determine the result of the comparison.


\subsubsection*{Input and output}


\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class CharType, class CharTrait, class T1, class T2, ..., class TN>
basic_ostream<CharType, CharTrait>& 
operator<<(basic_ostream<CharType, CharTrait>& os, 
           const tuple<T1, T2, ..., TN>& t);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} For all $i$ = 0, 1, ..., N-1 in \verb|os << get<i>(t)|
is a valid expression.\\
\req{Effects:} Inserts \code{t} into \code{os} as \code{$L$t$_0$$d$t$_1$$d$...$d$t$_nR$}, where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple formatting manipulators.
Each element \code{t$_i$} is output by invoking \verb|os << get<i>(t)|.
A zero-element tuple is output as $LR$ and a one-element tuple is output as \code{$L$t$_0R$}.
\\
\req{Returns:} \code{os}

\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class CharType, class CharTrait, class T1, class T2, ..., class TN>
basic_istream<CharType, CharTrait>& 
operator>>(basic_istream<CharType, CharTrait>& is, 
           tuple<T1, T2, ..., TN>& t);
\end{verbatim}
\end{minipage}

\medskip 

\req{Requires:} For all $i$ = 0, 1, ..., N-1 in \verb|is >> get<i>(t)|
is a valid expression.\\
\req{Effects:} Extracts a tuple of the form \code{$L$t$_0$$d$t$_1$$d$...$d$t$_nR$},
where $L$ is the opening, $d$ the delimiter and $R$ the closing
character set by tuple formatting manipulators.
Each element \code{t$_i$} is extracted by invoking \verb|is >> get<i>(t)|.
A zero-element tuple expects to extract $LR$ from the stream and 
one-element tuple expects to extract \code{$L$t$_0R$}.
If bad input is encountered, calls \code{is.set\_state(ios::failbit)} (which
may throw \code{ios::failure} (27.4.4.3)).\\
\req{Returns:} \code{is}\\
\req{Notes:} It is not guaranteed that a tuple written to 
a stream can be extracted back to a tuple of the same type.

\subsubsection*{Tuple formatting manipulators}

The library defines the following three stream manipulator functions.
The types designated \emph{tuple\_manip1}, \emph{tuple\_manip2} and \emph{tuple\_manip3} are implementation-specified.

\medskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{alltt}
\textrm{\emph{tuple_manip1}} tuple_open(char_type c);
\textrm{\emph{tuple_manip2}} tuple_close(char_type c);
\textrm{\emph{tuple_manip3}} tuple_delimiter(char_type c);
\end{alltt}
\end{minipage}

\medskip 

\req{Returns:} Each of these functions returns an object \code{s} of unspecified 
type such that if \code{out} is an 
instance of \code{basic\_ostream<charT,traits>}, \code{in} is an instance of
\code{basic\_istream<charT,traits>} and \code{char\_type} equals \code{charT},
then the expression \verb|out << s| (respectively \verb|in >> s|) 
sets \code{c} to be
the opening, closing, or delimiter character (depending on the manipulator
function called) to be used when writing tuples into \code{out} (respectively
extracting tuples from \code{in}).\\
\req{Notes:} Implementations are not required to support these manipulators for 
streams with \code{sizeof(charT) > sizeof(long)}; \verb|out << s| and \verb|in >> s| are required to fail at compile time if 
\code{out} and \code{in} are such streams and the implementation does not
support tuple formatting manipulators for them.

\medskip 

\noindent \textsf{[The constraint stated in the above \textbf{Notes} section allows an 
implementation where the delimiter characters are stored in
space allocated by \code{xalloc}, which allocates an array of \code{long}s.
A more general alternative is to store pointers to the delimiter 
characters in the \code{xalloc}-allocated array, and register a callback 
function (with \code{ios\_base::register\_callback}) for the stream to 
take care of deallocating the memory.
If this approach is taken, the delimiters could be chosen to be strings 
instead of single characters.
This might be worthwhile, such as to allow delimiters like \code{", "}.
]}


\section{Utility components}

The library provides the class template \code{reference\_wrapper} that 
stores a reference to an object in a CopyConstructible wrapper, and two 
\code{reference\_wrapper} construction functions that allow the user to 
express the intent in storing a reference instead of a copy.

\medskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{alltt}
template<typename T>
class reference_wrapper \{
public:
  typedef T type;
   
  explicit reference_wrapper(T &);

  operator T& () const;
  T& get() const;
\};
\end{alltt}
\end{minipage}

\medskip 

\noindent\hspace{\parindent}  
\verb|explicit reference_wrapper(T& t));|

\medskip 

\req{Postconditions:} \verb|this->get()| is equivalent to \code{t}.\\
\req{Throws:} will not throw.

\bigskip

\noindent\hspace{\parindent}  
\verb|operator T& () const;|

\medskip 

\req{Returns:} \verb|this->get()|\\
\req{Throws:} will not throw.

\bigskip 

\noindent\hspace{\parindent}  
\verb|T& get() const;|

\medskip

\req{Returns:} the stored reference.\\
\req{Throws:} will not throw.

\bigskip 

\noindent\hspace{\parindent}  
\verb|template<typename T> reference_wrapper<T> ref(T& t);|

\medskip 

\req{Returns:} \verb|reference_wrapper<T>(t)|\\
\req{Throws:} will not throw.

\bigskip 

\noindent\hspace{\parindent}  
\verb|template<typename T> reference_wrapper<T const> cref(const T& t);|

\medskip 

%\req{Requires:} \code{T} cannot be a function type.\\
%\textsf{[This requirement may be unnecessary depending on the resolution of
%core language issue 295]}\\
\req{Returns:} \verb|reference_wrapper<T const>(t)|\\
\req{Throws:} will not throw.

\bigskip 

\noindent The library provides the class \code{swallow\_assign}:
%

\medskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
struct swallow_assign {
  template <class T> 
  swallow_assign& operator=(const T&) { return *this; }
};
\end{verbatim}
\end{minipage}

\bigskip 

\noindent The library provides an object
\code{ignore} of type \code{swallow\_assign}.

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
extern swallow_assign ignore;
\end{verbatim}
\end{minipage}


\section{Pairs}

\textsf{[Additions to pair to work with tuples]}

\medskip 

%Pairs are tuple-like types (see \textsf{[number of the section where tuple-like
%is defined]}). The following subclauses define the semantics of the 
%expressions pair types must support to comply to the tuple-like requirements. 

%\subsubsection*{Notation}
%
%\begin{tabular}{lp{10cm}}
%\code{P} & is an instance of the \code{pair} template\\
%\code{p}, \code{pc} & are objects of types \code{P} and \code{const P}
%\end{tabular}

%\bigskip 

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2>
struct tuple_size<pair<T1, T2> > {
  static const int value = 2;
};
\end{verbatim}
\end{minipage}

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<class T1, class T2>
struct tuple_element<0, pair<T1, T2> > {
  typedef T1 type;
};

template<class T1, class T2>
struct tuple_element<1, pair<T1, T2> > {
  typedef T2 type;
};
\end{verbatim}
\end{minipage}

\bigskip

\noindent\hspace{\parindent}  
\begin{minipage}{10.5cm}
\begin{verbatim}
template<int I, class T1, class T2>
P& get(pair<T1, T2>&);

template<int I, class T1, class T2>
const P& get(const pair<T1, T2>&);
\end{verbatim}
\end{minipage}

\medskip 

\req{Return type:} 
If \code{I} is \code{0} then \code{P} is \code{T1}, 
if \code{I} is \code{1} then \code{P} is \code{T2},
otherwise the program is ill-formed.\\
\req{Returns:} If \code{I == 0} returns \code{p.first}, otherwise
returns \code{p.second}.

\bigskip


\section{Acknowledgements}

The author is indebted to Jeremiah Willcock, Douglas Gregor and Gary Powell,
as well as to Jeremy Siek and Dave Abrahams for their invaluable help 
in preparing this document.
%
The Boost Tuple Library, the basis of this proposal, has benefited from 
suggestions by many in the Boost community, including 
Jens Maurer, William Kempf,
 Vesa Karvonen, John Max Skaller,
Ed Brey, Beman Dawes, and Hartmut Kaiser.


\bibliography{tuple_proposal}
\bibliographystyle{plain}


\end{document}


\section{Discussion about some design choices}

\subsection{About valid element types\label{about_valid_element_types}}

The proposed requirements state, that there are no restrictions on the types
of tuple elements, if the program contains no construction invocations 
for the tuple type.
For example, \code{void} and \code{int()()} are valid C++ types, but 
objects of these types can never be created. 
Hence, \code{tuple<void, int()()>} is a valid tuple type but obviously an
object of this type cannot be constructed.

A straightforward implementation, where the type of a template
parameter is a type of a member variable, does not fullfil the above
restriction. The types of the member variables are checked when the template 
is instantiated, and \code{void} and function types are rejected as member
types, even though an object is never constructed.

The way to cope with this issue is to transform each member through
a traits class, wrapping \code{void} and function types to something 
that can be a member variable, but cannot be constructed.

This means extra clutter in the code implementing tuple types, but
we find the feature important for uniformity. 
Otherwise tuple types would impose a restriction that does not exist
for the element types.

\subsubsection{Defining functions for the standard tuple type
vs. types that are tuple-like.}

In the proposal, tuple-like types do not support all the same operations
than tuple types.


\subsubsection{Element type as a nested or separate class template\label{nested_or_separate}}

\subsubsection{About element access\label{element_access}}

There are several alternative syntaces for element access. 
We list some of these choices with explanations:
%\begin{}
%\item \code{get<N>(t)} 


%t.get<N>();

%t.get(index<N>);
%t[index<N>];

%\end{itemize}
\subsection{About comparison operators\label{lexicographical_ordering}}

T
Mathematically wrong for product types, but practical.
(JAAKKO: stick somewhere justification, std::pair,
Haskell)

%\code{About tuples as built-in types\label{built-in_tuples}}
%
%Particularly, many languages consider the argument list to a function to
%be implicitly a tuple object (lanXXX, langYYY).
%This would be a remarkable improvement for generic programming in C++, 
%making truly generic wrapping, delegating, or forwarding functions possible.
%For example, the problem of not being able to inherit constructors would
%cease to exist, as one could define a constructor taking any tuple, and
%forward the tuple to the base class.

% Another important point EIFFEL, 
% Also, it is should be noted, that the programming language Eiffel does not
% allow varying number of generic parameters, except for tuple tuple types.
% The author is personally convinced that a built-in tuple type, with argument
% list of a function being implicitely a tuple object, and a mechanism to 
% (More on appendix)


%- Miksi assignment riittää paireista tupliin
%- Mikä on tuple\_size:n return type


The tuple type is impelemented as an interface template \code{tuple} that
can take up to $n$ (10 in the reference implementation) template arguments.
It is very tedious to overload functions for such a verbose type.
Consequently, the \code{tuple} interface class inherits from instantiations
of another type (\code{cons}) which represents the tuple element as a 
\emph{cons list}.
Comparison operators, streaming operators and element accessor functions all 
operate on the cons list representation.

We propose this representation be standardized as well, to give end programmers
a convenient way to overload functions for tuple types. 

\end{document}


\begin{sf}
\noindent [The tuple template has a large number of template parameters (10) 
or more, and it is thus tedious to overload functions for such a type.
In one possible implementation, the \code{tuple} interface class inherits 
from another template (say a cons list) which only has two template
parameters and represents tuples as a recursive instantiations of the
same template. 
The tuple operations can be defined much more succinctly for 
such recursively defined types.
See~\cite{cit:boost_tuple_library:01,jarvi:01:cuj_tuples} for an example.

However, this affects the way overload resolution works.
If some type \code{B} inherits from an instance of some template 
\code{A<T>}, a function with a fully generic interface is a better match
for \code{B} than a function overloaded for \code{A<T>}.
E.g.:
\begin{verbatim}
template <class T> void foo(const T& t); 
template <class T> void foo(const A<T>& t); 
class B : public A<int> {};
B b; 
foo(b); // \cccomment{calls the first, fully generic definition of foo
\end{verbatim}
overloading rules for templates make a fully generic template
function (\verb|template <class T> foo(const T& t)|) a better match.

Considering the subtlety of the way overload resolution works in this case, 
the explicit mention that the implementation is allowed to define the operators
with a function that is a worse match than a fully generic function,
is in order.
]
\end{sf}


\begin{verbatim}
cons(const typename remove_volatile<head_type>::type& h, 
     const tail_type& t);
\end{verbatim}
\requires{All elements are \concept{CopyConstructible}}.
\effects\ Initializes \code{head\_} with \code{h}
and \code{tail\_} with \code{t}.\\
\notes\ 
Unless \code{head\_type} is a non-const reference type, it is allowed 
to call the constructor with a temporary as the first argument.
When binding temporaries to references, the reference must
be to a non-volatile and const type (8.5.3 (5)). Thus \code{volatile}
is removed and \code{const} added. Reference types stay intact.


\begin{verbatim}
template <class H2, class T2> cons(const cons<H2, T2>& u);
\end{verbatim}

\effects\ Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.



\begin{verbatim}
cons& operator=(const cons& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}\\
\notes\ Default assignment operator is illformed if a class contains
member variables of reference types (12.8 (12)). 
Therefore an explicit definition is needed.

\begin{verbatim}
template <class T1, class T2> cons& operator=(const std::pair<T1, T2>& u);
\end{verbatim}
\requires\ \code{tuple\_size<cons> == 2} (ref????).\\
\effects\ As if implemented: 
\code{*this.head\_ = u.first; *this.tail\_.head\_ = u.second;}\\
\returns\ \code{*this}


\returns\ Reference to \code{head\_}.\\
\notes\ Constness is shallow. If \code{head\_type} is a non-const reference 
type, returns a non-const reference.






Osat:

- introduction to tuples

- text in standard

- reference implementation

- about the reference implementation


TODO:

- laita comparison-operaattoreihin conversion to bool before ! operator
-  change static cast to reintepret cast in or something in manipulators

- PREPROCESSOR_CONSTANT for max tuple length
- traits: (no limit)


