\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

%\usepackage[finnish]{babel}

\newcommand{\effects}{\noindent \textbf{Effects:}}
\newcommand{\returns}{\noindent \textbf{Returns:}}
\newcommand{\returntype}{\noindent \textbf{Return type:}
\newcommand{\semantics}{\noindent \textbf{Returns:}}}
\newcommand{\requires}{\noindent \textbf{Requires:}}
\newcommand{\notes}{\noindent \textbf{Notes:}}
\newcommand{\values}{\noindent \textbf{Value:}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\concept}[1]{\textsf{#1}}

\author{Jaakko J‰rvi}

\title{Proposal for adding tuple types into the standard library\\N1382=02-0040}


\begin{document}
\maketitle{}

\section{Motivation}

This proposal describes tuple types implemented as a template library.
The proposal is a generalization of the \code{pair} template from two
to arbitrary (up to a predefined limit) number of elements.
Compared to pairs, the proposed tuple template supports a wider range 
of element types (e.g. references), streaming oprerators are provided,
and \code{tie} functions, that ...

Tuple types are a general utility for the end user, to be used similarly 
to pairs. 
Also, tuples are an important tool for library implementers for representing
a set of template arguments, a set of function arguments, etc. as a single
entity.

The library provides \code{tie} functions for creating tuples with reference
elements. These make tuples convenient as return types of functions.
\textbf{JAAKKO: esimerkki}.

\section{Impact on the standard}

The proposed library does not require any core language changes,
or modifiation to existing standard library headers, if the definitions
are included in \code{<utility>}, the location of the \code{pair} template.
However, operators for reading tuples from a stream and writing tuples into
a stream do introduce a dependency to streams.
\textbf{JAAKKO: mit‰s t‰st‰ sitten pit‰isi sanoa}.

Note however, that tuples would benefit from a set of core language changes:
\begin{itemize}
\item Variable length template argument lists.
\item Making reference to a reference to some type \code{T} equal to 
reference to \code{T}.
\item Allowing default arguments (both template and function) for function
templates.
\end{itemize}

\section{Design}

The tuple type is impelemented as an interface template \code{tuple} that
can take up to $n$ (10 in the reference implementation) template arguments.
It is very tedious to overload functions for such a verbose type.
Consequently, the \code{tuple} interface class inherits from instantiations
of another type (\code{cons}) which represents the tuple element as a 
\emph{cons list}.
Comparison operators, streaming operators and element accessor functions all 
operate on the cons list representation.
\section{Text in the standard}

\subsection{Tuples}

The library provides a template for a heterogeneous list of objects, 
and an interface for easier handling of these lists as tuple types.

\noindent \textbf{Header} \verb|<tuple>| synopsis

\begin{verbatim}
class null_type {}

template <class H, class T> class cons; 

template <class T0 = null_type, class T1 = null_type, ..., 
          class TN = null_type> 
class tuple;

template<class T> int tuple_size(const T&);
int tuple_size(null_type);

template <int N, class T> class tuple_element;
template <int N, class H, class T> rt? get(cons<H, T>&);
template <int N, class H, class T> rt? get(const cons<H, T>&);

inline bool operator==(const null_type&, const null_type&);
inline bool operator!=(const null_type&, const null_type&);
inline bool operator<(const null_type&, const null_type&);
inline bool operator>(const null_type&, const null_type&);
inline bool operator>=(const null_type&, const null_type&);
inline bool operator<=(const null_type&, const null_type&);


template <class H1, class T1, class H2, class T2>
inline bool operator==(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator!=(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator<(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator>(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator<=(const cons<H1, T1>& a, const cons<H2, T2>& b);
template <class H1, class T1, class H2, class T2>
inline bool operator>=(const cons<H1, T1>& a, const cons<H2, T2>& b);

\end{verbatim}


The type of the heterogeneous list type is:

\begin{verbatim}
class null_type {};

template <class H, class T>
class cons {
  H head_;
  T tail_;
public:
  typedef H head_type;
  typedef T tail_type;

  head_type& head();
  const head_type& head() const;

  tail_type& tail();
  const tail_type& tail() const;

  cons();
  cons(const typename remove_volatile<head_type>::type& h,
       const tail_type& t);

  template <class H2, class T2>
  cons( const cons<H2, T2>& u ) : head(u.head), tail(u.tail) {}

  template <class HT2, class TT2>
  cons& operator=( const cons<HT2, TT2>& u );

  cons& operator=(const cons& u);

  template <class T1, class T2>
  cons& operator=( const std::pair<T1, T2>& u );
}
\end{verbatim}

\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}.

\begin{verbatim}
cons();
\end{verbatim}
\effects\ Default initializes \code{head\_} and \code{tail\_}.

\begin{verbatim}
cons(const typename remove_volatile<head_type>::type& h, 
     const tail_type& t);
\end{verbatim}
\requires{All elements are \concept{CopyConstructible}}.
\effects\ Initializes \code{head\_} with \code{h}
and \code{tail\_} with \code{t}.\\
\notes\ 
Unless \code{head\_type} is a non-const reference type, it is allowed 
to call the constructor with a temporary as the first argument.
When binding temporaries to references, the reference must
be to a non-volatile and const type (8.5.3 (5)). Thus \code{volatile}
is removed and \code{const} added. Reference types stay intact.


\begin{verbatim}
template <class H2, class T2> cons(const cons<H2, T2>& u);
\end{verbatim}

\effects\ Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.


\begin{verbatim}
template <class HT2, class TT2> cons& operator=(const cons<HT2, TT2>& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}


\begin{verbatim}
cons& operator=(const cons& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}\\
\notes\ Default assignment operator is illformed if a class contains
member variables of reference types (12.8 (12)). 
Therefore an explicit definition is needed.

\begin{verbatim}
template <class T1, class T2> cons& operator=(const std::pair<T1, T2>& u);
\end{verbatim}
\requires\ \code{tuple\_size<cons> == 2} (ref????).\\
\effects\ As if implemented: 
\code{*this.head\_ = u.first; *this.tail\_.head\_ = u.second;}\\
\returns\ \code{*this}

\begin{verbatim}
head_type& get_head();
\end{verbatim}
\returns\ Reference to \code{head\_}. 

\begin{verbatim}
const head_type& get_head() const;
\end{verbatim}
\returns\ Reference to \code{head\_}.\\
\notes\ Constness is shallow. If \code{head\_type} is a non-const reference 
type, returns a non-const reference.

\begin{verbatim}
tail_type& get_tail();
const tail_type& get_tail() const;
\end{verbatim}
\returns\ Reference to tail. %NIL CASE ???

The library provides traits classes for querying 
properties of tuples and their elements:

\begin{verbatim}
tuple_size<T>::value
\end{verbatim}
\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}. \\
\values\ \code{const int} holding the number of elements in the cons list \code{T}.

\begin{verbatim}
tuple_element<N, T>::type
\end{verbatim}
\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}. \\
$0 \leq $ \code{N} $ < $ \code{tuple\_size<T>::value}.
\values\ The type of the \code{N}th element in \code{T}.

\begin{verbatim}
template <int N, class H, class T> rt? get(cons<H, T>&);
template <int N, class H, class T> rt? get(const cons<H, T>&);
\end{verbatim}

\begin{verbatim}
inline bool operator==(const null_type&, const null_type&);
inline bool operator>=(const null_type&, const null_type&);
inline bool operator<=(const null_type&, const null_type&);
\end{verbatim}
\returns\ \code{true}.

\begin{verbatim}
inline bool operator!=(const null_type&, const null_type&);
inline bool operator<(const null_type&, const null_type&);
inline bool operator>(const null_type&, const null_type&);
\end{verbatim}
\returns\ \code{false}.

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator==(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}
\returns\ \code{true} if all elementwise comparisons are true.
\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator!=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator<(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator>(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator<=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator>=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}





%template <class T1, class T2, ... class T10>
%class tuple {
%public:



\subsection{Tuples}



\concept{ConsList} requirements:

ConsLists are heterogeneous containers. 
They allow the access to
the \emph{head} (first element) and \emph{tail} (a ConsList consisting
of all but the head), as well as to the $n$th element, where $n$ is 
known at compile time.

\paragaph{Notation}
\tabular{ll}
\code{T} & is a type that is a model of \concept{ConsList}
\code{t} & object of type \code{T}
\code{U} & is a type that is a model of \concept{ConsList}
\code{u} & object of type \code{U}

\paragraph{Participating types}

\paragraph{Valid Expressions}
\begin{itemize}

\item Number of elements

\code{T::length} 

\returntype\ \code{static const int}.\\
\semantics\ Number of elements in \code{T}.\\

& integral constant, number of elements in \code{T} \\

\end{itemize}




\begin{tabular}{lll}

\code{T} and \code{U} are types to be supplied by a C++ program 
intantiating a template, \code{t} is a value of type \code{T}, 
\code{u} a value of type \code{U}, \code{tc} and \code{uc} are 
value of types \code{const T} and \code{const U} respectively.





\concept{NonEmptyConsList} requirements:

The \concept{ConsList} 

\code{T} and \code{U} are types to be supplied by a C++ program 
intantiating a template, \code{t} is a value of type \code{T}, 
\code{u} a value of type \code{U}, \code{tc} and \code{uc} are 
value of types \code{const T} and \code{const U} respectively.

\begin{tabular}{lll}

\textbf{expression} & \textbf{return type} & \textbf{requirement} \\

\code{T::head\_type} & the type of the first element in \code{T} \\

\code{T::tail\_type} & a type \code{TT} that is a model of \concept{ConsList} 
and ... \\

\code{t.head()} & \code{T::head\_type\&} \\

\code{t.head() const} & \code{const T::head\_type\&} & \\

\code{a.tail()} & \code{T::tail\_type\&} \\

\code{a.tail() const} & \code{const T::tail\_type\&} & \\

\code{T::length} & integral constant, number of elements in \code{T} \\

\code{T(u)} & & \code{u} is equivalent to \code{T(u)}\\

\end{tabular}



\code{tuple} is a class template that can be instantiated with any number
of arguments, up to a predefined limit \code{N}.
Each template argument specifies the type of an element int the \code{tuple}.

\subsubsection{Constructors}

\begin{verbatim}
tuple<T0, T1, ... TN>(); 
\end{verbatim}
\requires\ Each element type must be \concept{DefaulConstructible}.
\effects\ Default initializes each element.

\begin{verbatim}
tuple<T0, T1, ... TN>(t0, t1, ..., tN); 
\end{verbatim}
\requires\ Each element type must be \concept{CopyConstructible}.
\effects\ Copy initializes each element with the value of the corresponding 
parameter.

\begin{verbatim}
template <class U>
tuple<T0, T1, ... TN>(const U& u); 
\end{verbatim}
\requires\ 

\begin{verbatim}
  template <class T0, class T1, ... class TN>

  class tuple {

    typedef T0 head_type;
    typedef tail_type;  

    tuple() : base() {}
  
    // tuple_traits_parameter<T>::type takes non-reference types as const T& 
    explicit 
    tuple(typename tuple_detail::parameter<T0>::type t0,
	  typename tuple_detail::parameter<T1>::type t1 
	    = tuple_detail::def_value<T1>::f(),
	  typename tuple_detail::parameter<T2>::type t2 
	    = tuple_detail::def_value<T2>::f(),
	  typename tuple_detail::parameter<T3>::type t3 
	    = tuple_detail::def_value<T3>::f(),
	  typename tuple_detail::parameter<T4>::type t4 
	    = tuple_detail::def_value<T4>::f(),
	  typename tuple_detail::parameter<T5>::type t5 
	    = tuple_detail::def_value<T5>::f(),
	  typename tuple_detail::parameter<T6>::type t6 
	    = tuple_detail::def_value<T6>::f(),
	  typename tuple_detail::parameter<T7>::type t7 
	    = tuple_detail::def_value<T7>::f(),
	  typename tuple_detail::parameter<T8>::type t8 
	    = tuple_detail::def_value<T8>::f(),
	  typename tuple_detail::parameter<T9>::type t9 
	    = tuple_detail::def_value<T9>::f())
      : base(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}
    
    template<class U1, class U2>
    tuple(const cons<U1, U2>& p) : base(p) {}

    template <class U1, class U2>
    tuple& operator=(const cons<U1, U2>& k) { 
      base::operator=(k); 
      return *this;
    }

    template <class U1, class U2>
    tuple& operator=(const std::pair<U1, U2>& k) { 
      BOOST_STATIC_ASSERT(tuple_size<tuple>::value == 2);// check_size = 2
      this->head = k.first;
      this->tail.head = k.second; 
      return *this;
    }
    
  };
\end{verbatim}



\end{document}

- Onko non-storeable trikki tarpeellinen

- Miksi assignment riitt‰‰ paireista tupliin
- Mik‰ on tuple_size:n return type
