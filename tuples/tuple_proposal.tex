\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

%\usepackage[finnish]{babel}

\newcommand{\effects}{\noindent \textbf{Effects:}}
\newcommand{\returns}{\noindent \textbf{Returns:}}
\newcommand{\returntype}{\noindent \textbf{Return type:}}
\newcommand{\requires}{\noindent \textbf{Requires:}}
\newcommand{\notes}{\noindent \textbf{Notes:}}
\newcommand{\values}{\noindent \textbf{Value:}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\concept}[1]{\textsf{#1}}

\author{Jaakko Järvi}

\title{Proposal for adding tuple types into the standard library\\N1382=02-0040}


\begin{document}
\maketitle{}

Osat:

- introduction to tuples

- text in standard

- reference implementation

- about the reference implementation


TODO:

- laita comparison-operaattoreihin conversion to bool before ! operator

\section{Motivation}

This proposal describes tuple types for C++.
Everything proposed here can be implemented as a library, but the proposal
intentionally leaves room for tuples as a built in type.
We do not propose a fixed implementation, as there are several alternatives
for implementing tuples. Also, new language features, such as variable
length template argument lists may make currently unimplementable approaches
possible.

Tuple template is basically a generalization of the \code{pair} template 
from two to arbitrary (up to a predefined limit) number of elements.
Compared to pairs, the proposed tuple template supports a wider range 
of element types (e.g. references) and streaming operations, customizable
with specific manipulators.
Further, the library provides \code{tie} functions for creating tuples 
with reference elements. 
These make tuples convenient as return types of functions.


Tuple types are a general utility for the end user, to be used similarly 
to pairs. 
Also, tuples are an important tool for library implementers for representing
a set of template arguments, a set of function arguments, etc. as a single
entity.
\textbf{JAAKKO: esimerkkiejä}.

\section{Impact on the standard}

The proposed library does not require any core language changes.
We propose tuple definitions to be included by including the \code{<utility>} 
header, which is where \code{pair} resides in.
However, operators for reading tuples from a stream and writing tuples into
a stream do introduce a dependency to \code{<istream>} and \code{<ostream>}.
\textbf{JAAKKO: should istream and ostream include utility, should there
be tupleio header ??=}.

Note that tuples would benefit from a set of core language changes:
\begin{itemize}
\item Variable length template argument lists.
\item Making reference to a reference to some type \code{T} equal to 
reference to \code{T}.
\item Allowing default arguments (both template and function) for function
templates.
\end{itemize}

\section{Tuples in a nutshell}

\subsection{Defining tuple types}

The \code{tuple} template can be instantiated with any number of arguments
between 0 and 10 elements. 
The argument types can be any valid C++ types.
Examples:
\begin{verbatim}
typedef tuple<A, const B, volatile C, const volatile D> t1;
typedef tuple<int, int&, const int&, const volatile int&> t2;
typedef tuple<void, int()(int)> t3;
\end{verbatim}

\subsection{Constructing tuples}

A $n$ element tuple has a default constructor, 
converting copy constructor, 
and a constructor with $n$ parameters.
The types of the elements restrict which constructors can be used:
\begin{itemize}
\item If an $n$-element tuple is constructed with a constructor taking 
0 elements, all elements must be default constructible.

\item If an $n$-element tuple is constructed with a constructor taking 
$n$ elements, all elements must be copy constructible and implicitly 
convertible from the corresponding argument.
For example
\begin{verbatim}
tuple<int, const int, std::string>(1, 'a', "Hi")
\end{verbatim}

\item If an $n$-element tuple is constructed with the converting copy 
constructor, the argument type must be a model of the \concept{Tuple} concept
and the each element must be elementwise copy constructible.
\end{itemize}

\begin{verbatim}
tuple<int, float, std::string> t1;
t1 = tuple<char, int, char[]>('a', 1, "Hi");
\end{verbatim}


\subsection{Assignment}

The assignment operation is defined from any object that models
the \concept{Tuple} concept and where the element types are elementwise 
assignable.

\subsection{Number of elements, element types}

Tuples make the number of element accessible as a compile time constant 
\code{size}.
\begin{verbatim}
tuple<int, int, int, int>::size; // equals 4
\end{verbatim}

The type of the \code{N}th element can be accessed as a typedef within
a nested template \code{element}:
\begin{verbatim}
tuple<int, char, float, double>::element <2>::type // float
\end{verbatim}
Indexing is zero based. Index out of bounds results in a compilation error.

\subsection{Element access}

Let \code{t} be a tuple object. 
The expression t[index<N>] returns the reference to the \code{N}th element
of \code{t}, where \code{N} is an integral constant expression.
\begin{verbatim}
tuple<int, float, char>(1, 3.14, 'a') t;
t.[index<2>] // equals 'a'
\end{verbatim}
Indexing is zero based. Index out of bounds results in a compilation error.

\subsection{Relational operators}

A relational operator \emph{op} is defined between two tuples \code{T} 
and \code{U}, iff \code{T} and \code{U} have the same number of elements,
and for all element positions, \emph{op} is defined between the element 
from \code{T} and the element from \code{U}.
\begin{verbatim}
tuple<int, float, char> t; 
tuple<int, char, int> u;
t < u; // is defined

tuple<int, int, int, int> x;
tuple<int, int, int> y; 
x < y; // not defined, different size

tuple<int, int, complex<double>, int> x;
tuple<int, int, std::string, int> y; 
x < y; // not defined, no operator< between complex<double> and std::string
\end{verbatim}

The operators \code{<}, \code{>}, \code{<=}, \code{>=} each define a 
lexicographical ordering. (JAAKKO: stick somewhere justification, std::pair,
Haskell)
The \code{operator==} is defined as the logical and of the elemenwise 
equality comparisons.
The \code{operator!=} is defined as the logical or of the
elementwise comparisons.

Each comparison operator \emph{op} is defined solely using the same
operator \emph{op} for the elementwise comparisons and makes no assumptions
about the behaviour respect to the other relational operators, or even
to whether they are defined or not.

\subsection{Input and output}

A tuple type is \concept{OutputStreamable} (JAAKKO: explain these concepts)
if each of its elements are 
\code{OutputStreamable}.
A tuple is \concept{InputStreamable} if each of its elements are 
\concept{InputStreamable}.
Note however, that in general it is not guaranteed, that a tuple written to 
an ostream can be read back from an istream to a tuple that can be
written to an ostream , and if the delimiters that are used between
the two 

Tuple objects can be written to an ostream with \code{operator<<} if
each element is 
read from an istream with \code{operator>>}.


We describe an implementation that conforms to the requirements
of this proposal.

\section{Text in the standard}

\section{Tuple Library}

The library provides a tuple type as 
the class template \code{tuple} that can be instantiated with any number
of arguments.
The implementation can set an upper limit for the number of arguments.
Each template argument specifies the type of an element in the \code{tuple}.
Consequently, tuples are heterogeneous fixed size collections.
of values. 

Implementation quantites:

- Number of elements in one tuple type [10].

Implementations are allowed to define the tuple template as an interface,
which inherits from some templated base class \code{T}.
If \code{T} provides all the functionality provided , and overload tuple operations (converting copy
constructors, assignments, conversion operators, etc.) for the \code{T}
templates, instead of \code{tuple} templates.


The following subclauses describe the requirements for the tuple
type.


\subsubsection{Notation}

\begin{tabular}{ll}
\code{T}, \code{U} & are tuple types\\
\code{t}, \code{u} & objects of types \code{T} and \code{U}\\
\code{tc}, \code{uc} & objects of types \code{const T} and \code{const B}\\
\code{p} & an object whose type is a potentially cv-qualified instance of \code{pair}, or whose type inherits from a potentially cv-qualified instance of \code{pair}. (JAAKKO, make this shorter)\\
\code{T$_i$} & the type of the $i$th element in \code{T}\\
\code{t$_i$} & the $i$th element of \code{t}
\end{tabular}

\noindent The notation \code{T1, T2, ..., Tn} 
stands for a comma separated list of
types which may contain any number of elements from 0 to \code{n} 
(where \code{n} <= maximum number of allowed tuple elements), 
and \code{t1, t2, ..., tn} respectively for a set of objects. 

\paragraph{Participating types}

\paragraph{Valid Expressions}

\begin{itemize}

\item Number of elements

\code{T::size} \\
\code{tuple\_traits<T>::size}\\
\returntype\ \code{const int} (integral constant expression).\\
\values\ Number of elements in \code{T}.

\item Element type

\code{T::element<N>::type}\\
\code{tuple\_traits<T>::element<N>::type}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\ 
\values\ The type of the \code{N}th element type of tuple type \code{T}.

\item Element access

\code{get<N>(t)}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\
\returntype\ \code{T::element<N>::type\&}.\\
\returns\ A reference to the \code{N}th element of \code{t}.


\code{get<N>(tc)}\\
\requires\ 0 <= \code{N} < \code{T::size}.\\
\returntype\ \code{const T::element<N>::type\&}.\\
\returns\ A reference to the \code{N}th element of \code{tc}.\\
\notes\ Constness is shallow. If \code{T::element<N>::type} is 
X\&, the return type is X\&, not const X\&.

\item Assignment

\code{t = u}\\
\requires\ \code{T::size == U::size}. For all $i$, \\
\code{t$_i$ = u$_i$} is a valid expression.\\
\effects\ Performs \code{t$_i$ = u$_i$} for all $i$.\\
\returntype\ \code{T\&}.\\
\returns\ \code{t}.

\code{t = p}\\
\requires\ \code{T::size == 2}. \code{t$_i$ = p.first} and 
\code{t$_i$ = p.second} are valid expressions.\\
\effects\ as if implemented: \code{t$_i$ = p.first; t$_i$ = p.second;}.\\
\returntype\ \code{T\&}.\\
\returns\ \code{t}.

\item Equality comparison

\code{t == u}\\
\requires\ \code{T::size == U::size}. For all $i$, \\
\code{t$_i$ == u$_i$} is a valid expression returning a type that is
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ \code{true} iff {t$_i$ == u$_i$} for all $i$.
For any two empty tuples \code{e} and \code{f}, \code{e == f} returns \code{true}.



\item Inequality comparison

\code{t != u}\\
\requires\ \code{T::size == U::size}.
For all $i$, 
\code{t$_i$ != u$_i$} is a valid expression returning a type that is 
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ \code{true} iff {t$_i$ != u$_i$} for some $i$.
For any two empty tuples \code{e} and \code{f}, \code{e != f} returns \code{false}.

\item \code{<}, \code{<=}, \code{>}, \code{>=} comparisons

\code{t $\bullet$ u}, where \code{$\bullet$} is one of \code{<}, \code{<=}, \code{>}, 
\code{>=}\\
\requires\ \code{T::size == U::size}. For all $i$, 
\code{t$_i$ $\bullet$ u$_i$} and \code{u$_i$ $\bullet$ t$_i$} are valid expressions 
returning a type that is 
convertible to \code{bool}.\\
\returntype\ \code{bool}.\\
\returns\ The result of a lexicographical comparison with \code{$\bullet$} between \code{t} and \code{u}, as if implemented:

\code{t$_i$ $\bullet$ u$_i$ || !((bool)(u$_i$ $\bullet$ t$_i$)) \&\&
                       t$_{\mathrm{tail}}$ $\bullet$ u$_{\mathrm{tail}}$}, where \code{r$_{\mathrm{tail}}$}
	is a tuple containing all but the first element of \code{r}.




\item Construction

\verb|tuple<T0, T1, ..., TN>()|\\
\requires\ Each element type can be default constructed.\\
\effects\ Default initializes each element.

\verb|tuple<T0, T1, ... TN>(t0, t1, ..., tN)|\\
\requires\ Each element type \code{Ti} type is
\concept{CopyConstructible}. JAAKKO: Are all requirements of CopyConstructible
required, probably not. Also, maybe even copy constrcution is required only
for some types that match directly. And what are references to copy constructible?
The type of each \code{ti} is convertible to \code{Ti}.\\
\effects\ Copy initializes each element with the value of the corresponding 
parameter.

\verb|tuple<T0, T1, ... TN>(u);|\\
\requires\ Each element type \code{Ti} is \concept{CopyConstructible},
(JAAKKO, see above). 
\code{u} has \code{N} elements. 
For each element index $i$, the type of \code{u$_i$} is 
convertible to \code{Ti}.\\
\effects\ Copy initializes each element $i$ with \code{u$_i$}.

\verb|tuple<T0, T1>(p)|, where \code{p} is an object of
of type \code{pair<X, Y>} (JAAKKO: or inhertis from one).\\
\requires\ \code{X} is convertible to \code{T0}, \code{Y} is convertible to 
\code{T1}.\\
\effects\ Copy initializes the first element with \code{t.first} and the 
second with \code{t.second}.

\item Input and output

\verb|o << t|, where \code{o} is an instance of \code|basic\_ostream| (JAAKKO, say somewhere, that is instance of means that is instance of or inherits
publicly from an instance of).\\
\requires\ For all $i$, \code{o << t$_i$} is a valid expression.\\
\effects\ Invokes \code{o << t$_i$} for each $i$.\\
\returntype\ \code{basic\_ostream}. (JAAKKO, say this differently)\\
\returns \code{o}.

\verb|i >> t|, where \code{i} is an instance of \code|basic\_istream| (JAAKKO, say somewhere, that is instance of means that is instance of or inherits
publicly from an instance of).\\
\requires\ For all $i$, \code{o >> t$_i$} is a valid expression,
and does not mess up parsing (JAAKKO, do something here).\\
\effects\ Invokes \code{o >> t$_i$} for each $i$.\\
\returntype\ \code{basic\_istream}. (JAAKKO, say this differently)\\
\returns \code{i}.

\item Manipulators


\end{itemize}

\end{document}

- Onko non-storeable trikki tarpeellinen

- Miksi assignment riittää paireista tupliin
- Mikä on tuple_size:n return type


The tuple type is impelemented as an interface template \code{tuple} that
can take up to $n$ (10 in the reference implementation) template arguments.
It is very tedious to overload functions for such a verbose type.
Consequently, the \code{tuple} interface class inherits from instantiations
of another type (\code{cons}) which represents the tuple element as a 
\emph{cons list}.
Comparison operators, streaming operators and element accessor functions all 
operate on the cons list representation.

We propose this representation be standardized as well, to give end programmers
a convenient way to overload functions for tuple types. 



The library provides traits classes for querying 
properties of tuples and their elements:

\begin{verbatim}
tuple_size<T>::value
\end{verbatim}
\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}. \\
\values\ \code{const int} holding the number of elements in the cons list \code{T}.

\begin{verbatim}
tuple_element<N, T>::type
\end{verbatim}
\requires\ \code{T} is an instance of \code{cons}, or \code{T} is 
\code{null\_type}. \\
$0 \leq $ \code{N} $ < $ \code{tuple\_size<T>::value}.
\values\ The type of the \code{N}th element in \code{T}.

\begin{verbatim}
template <int N, class H, class T> rt? get(cons<H, T>&);
template <int N, class H, class T> rt? get(const cons<H, T>&);
\end{verbatim}

\begin{verbatim}
inline bool operator==(const null_type&, const null_type&);
inline bool operator>=(const null_type&, const null_type&);
inline bool operator<=(const null_type&, const null_type&);
\end{verbatim}
\returns\ \code{true}.

\begin{verbatim}
inline bool operator!=(const null_type&, const null_type&);
inline bool operator<(const null_type&, const null_type&);
inline bool operator>(const null_type&, const null_type&);
\end{verbatim}
\returns\ \code{false}.

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator==(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}
\returns\ \code{true} if all elementwise comparisons are true.
\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator!=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator<(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator>(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator<=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}

\begin{verbatim}
template <class H1, class T1, class H2, class T2>
inline bool operator>=(const cons<H1, T1>& a, const cons<H2, T2>& b);
\end{verbatim}






\begin{verbatim}
cons(const typename remove_volatile<head_type>::type& h, 
     const tail_type& t);
\end{verbatim}
\requires{All elements are \concept{CopyConstructible}}.
\effects\ Initializes \code{head\_} with \code{h}
and \code{tail\_} with \code{t}.\\
\notes\ 
Unless \code{head\_type} is a non-const reference type, it is allowed 
to call the constructor with a temporary as the first argument.
When binding temporaries to references, the reference must
be to a non-volatile and const type (8.5.3 (5)). Thus \code{volatile}
is removed and \code{const} added. Reference types stay intact.


\begin{verbatim}
template <class H2, class T2> cons(const cons<H2, T2>& u);
\end{verbatim}

\effects\ Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.


\begin{verbatim}
template <class HT2, class TT2> cons& operator=(const cons<HT2, TT2>& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}


\begin{verbatim}
cons& operator=(const cons& u);
\end{verbatim}
\effects\ As if implemented: 
\code{*this.head\_ = u.head\_; *this.tail\_ = u.tail\_;}\\
\returns\ \code{*this}\\
\notes\ Default assignment operator is illformed if a class contains
member variables of reference types (12.8 (12)). 
Therefore an explicit definition is needed.

\begin{verbatim}
template <class T1, class T2> cons& operator=(const std::pair<T1, T2>& u);
\end{verbatim}
\requires\ \code{tuple\_size<cons> == 2} (ref????).\\
\effects\ As if implemented: 
\code{*this.head\_ = u.first; *this.tail\_.head\_ = u.second;}\\
\returns\ \code{*this}


\returns\ Reference to \code{head\_}.\\
\notes\ Constness is shallow. If \code{head\_type} is a non-const reference 
type, returns a non-const reference.




\begin{tabular}{lll}

\code{T} and \code{U} are types to be supplied by a C++ program 
intantiating a template, \code{t} is a value of type \code{T}, 
\code{u} a value of type \code{U}, \code{tc} and \code{uc} are 
value of types \code{const T} and \code{const U} respectively.




